package org.baiyunpengcoder.collection;

/**
 *    QUIC 流的生命周期:
 *        流是被切割成流帧的双向数据的独立序列。流可以由客户端或服务器创建，
 *        可以同时发送与其他流交错的数据， 并且可以取消。QUIC的流生存期与HTTP/2的[RFC7540]非常相似。
 *        流创建是通过为给定流发送 STREAM 帧隐式完成的。为了避免stream ID冲突，
 *        如果服务器启动流，stream ID必须为偶数，如果客户端启动流，stream ID必须为奇数。0不是有效的stream ID。
 *        stream 1 为加密握手保留，这应该是第一个客户端启动的流。在QUIC上使用HTTP/2时，stream3
 *        保留用于传输所有其他流的压缩头，确保头的可靠有序传递和处理。
 *        当创建新的流时，来自连接两侧的Stream-IDs 必须单调增加。
 *        E、 g. Stream  2可以在 Stream 3之后创建，但 Stream  7不能在 Stream 9之后创建。
 *        对等方可能接收到无序的流。
 *        例如，如果服务器在接收到  Stream 7 包含帧的 packet 9之前接收到 Stream 9 包含帧的 packet 10，
 *        那么它应该优雅地处理这个问题。
 *        如果接收 STREAM 帧 的端点不想接受流，它可以立即使用 RST_STREAM  帧（如下所述）进行响应。
 *        然而，请注意，发起端点可能已经在流上发送了数据；必须忽略此数据。
 *        一旦创建了流，就可以使用它来发送和接收数据。
 *        这意味着流上的QUIC端点可以发送一系列流帧，直到流在该方向终止。
 *        任一QUIC端点都可以正常终止流。有三种方式可以终止流：
 *              1、  正常终止：由于流是双向的，所以流可以是“半关闭”或“关闭”。当流的一侧发送FIN位设置为true的帧时，
 *                  流被认为在该方向上是“半闭合”的。FIN表示不会从此流上从FIN的发送方发送更多数据。
 *                  当QUIC端点同时发送和接收FIN时，该端点会将流视为“关闭”。虽然FIN应该与流的最后一个用户数据一起发送，
 *                  但FIN位可以在流的最后一个数据之后的空流帧上发送。
 *              2、  突然终止：客户端或服务器可以随时为流发送 RST_STREAM  帧。RST_STREAM 帧包含一个错误代码，
 *                  用于指示故障原因（错误代码在文档后面列出）当从流发起方发送 RST_STREAM  帧时，它指示未能完成流，
 *                  并且不会在流上发送进一步的数据。当从流接收器发送 RST_STREAM  帧时，
 *                  发送方在收到后应停止发送流上的任何数据。流接收器应该知道，
 *                  从发送器传输的数据与接收 RST_STREAM 帧的时间之间存在竞争。为了确保连接级流控制正确记帐，
 *                  即使接收到 RST_STREAM  帧，发送方也需要确保：对等方接收FIN和流中的所有字节，
 *                  或者对等方接收 RST_STREAM  帧。 这还意味着 RST_STREAM 帧的发送方需要使用适当的 WINDOW_UPDATEs
 *                  继续响应此流上的传入 STREAM_FRAME， 以确保发送方在尝试传递 FIN 时不会受到流控制阻止。
 *              3、  连接终止时，流也会终止
 *
 * @author baiyunpeng
 * @date 2022/6/17 14:25
 **/
public class StreamId {
}
