## 格式
x (A):  表示x的长度为A位
x (i):  指示x使用可变长度编码保存整数值 
x (A..B) 表示x可以是从A到B的任何长度;可以省略A以表示 最少为0比特，并且B可以省略以指示没有设置上限; 这种格式的值总是以字节边界结束
x (L) = C 表示x具有固定值C; x的长度描述为 L，它可以使用上面的任何长度形式
x (L) = C..D  表示x的值在C到D（包括C和D）的范围内， 长度用L表示
[x (L)]  表示x是可选的，长度为L
x（L）...： 指示x重复零次或多次，并且每个实例都有一个 L的长度

本文档使用网络字节顺序（即big endian）值。 字段 从每个字节的高阶位开始放置

## 流定义(Streams)
1. QUIC中的流为 应用程序。流可以是单向的，也可以是双向的
2. 可以通过发送数据来创建流。与流关联的其他进程 管理--结束、取消和管理流控制--都被设计成 以施加最小的管理费用。例如，单个STREAM帧 （19.8节）可以打开、携带数据流和关闭流。流可以 也是长期的并且可以持续连接的整个持续时间
3. 流可以由任一端点创建，可以并发发送数据 与其它流交织并且可以被消除。QUIC不提供任何 确保不同流上字节之间排序的方法
4. QUIC允许任意数量的流并发操作，并且 在任何流上发送的任意数量的数据，受流量控制 限制和 流限制

### 流类型和标识符(Stream Types and Identifiers)
1. 流可以是单向的，也可以是双向的。 单向水流携带 单向数据：从流的发起方到其对等方。 双向数据流允许在两个方向上发送数据
2. 连接中的流由一个数值标识，该数值称为 流ID是一个62位整数（0到2 × 62 - 1），即 对于连接上的所有流唯一。 流ID编码为 可变长度整数参见第16节。 QUIC端点不得 在连接中重用流ID。
3. 流ID的最低有效位（0x01）标识的发起者 小溪。 客户端启动的流具有偶数编号的流ID（使用 位设置为0），服务器启动的流具有奇数编号的流ID（具有 该位被设置为1）。
4. 流ID的第二个最低有效位（0x02）区分 双向数据流（位设置为0）和单向数据流（位设置为 该位被设置为1）

因此，来自流ID的两个最低有效位将流标识为 四种类型之一，如中所述表一。
Table 1 表一: ： Stream ID Types 流ID类型 
比特 	Stream Type 流类型
0x00 	Client-Initiated  Bidirectional 客户端启动，双向
0x01 	Server-Initiated  Bidirectional 服务器启动，双向
0x02 	Client-Initiated  Unidirectional 客户端启动，单向
0x03 	Server-Initiated  Unidirectional 服务器启动，单向
每种类型的流空间从最小值（0x00到0x03， ）;每种类型的连续流都是用数字 增加流ID。 未按顺序使用的流ID将导致所有 具有较低编号的流ID的那种类型的流也被打开

### 发送和接收数据(Sending and Receiving Data)
1. STREAM帧（19.8节）封装了应用程序发送的数据。安端点使用STREAM帧中的Stream ID和Offset字段将数据放入秩序
2. 端点必须能够按顺序向应用程序传递流数据 字节流。 传递有序字节流要求端点缓冲区 乱序接收的任何数据，直到通告的流量控制限制
3. QUIC没有特别考虑到流数据从 秩序。However  implementations MAY choose to offer the ability to deliver data 对接收应用程序来说是无序的
4. 端点可以在相同的流偏移倍数处接收流的数据 倍。 已经接收的数据可以被丢弃。 数据位于 given offset MUST NOT change if it is sent multiple times; an endpoint MAY treat 在作为连接的流内的相同偏移处接收不同数据 PROTOCOL_VIOLATION类型的错误
5. 流是一个有序的字节流抽象，没有其他可见的结构 至QUIC。 在以下情况下，不应保留STREAM帧边界 数据被传输、在数据包丢失后重新传输或传送到 在接收机处的应用
6. 端点在未确保数据流位于 由其对等体设置的流量控制限制

### 流优先级(Stream Prioritization)
在以下情况下，流多路复用会对应用程序性能产生重大影响 分配给流的资源被正确地优先化
1. QUIC不提供交换优先级信息的机制。 相反，它依赖于从应用接收优先级信息
2. QUIC实现应该提供应用程序可以指示的方法 流的相对优先级。 一种实现使用所提供的信息 以确定如何向活动流分配资源。

### 流上的操作(Operations on Streams)
本文件未定义QUIC的API;而是定义了一组 应用程序协议可以依赖的流上的函数。 一个应用程序 协议可以假设QUIC实现提供了 包括本节中介绍的操作。 设计的实施方案用于特定应用程序协议可能仅提供这些操作协议所使用的.

在流的发送部分，应用协议可以：
1. 写入数据，了解何时流流量控制信用 （第4.1节）已成功保留，以发送书面 数据
2. 结束流（干净终止），生成STREAM帧 （第19.8节），FIN位设置
3. 重置流（突然终止），产生RESET_STREAM帧 （19.4节），如果流还没有处于终止状态

在流的接收部分，应用协议可以:
1. 读取数据
2. 中止阅读流并请求关闭，可能导致 停止_发送帧
应用协议也可以请求被通知关于流，包括对等体打开或重置流时，对等体 中止阅读流，当新数据可用时，以及当数据可以或 由于流控制，无法写入流。

## 流状态(Stream States)
本节从流的发送或接收组件的角度描述流。 描述了两种状态机：一个用于其上的端点 传输数据（第3.1节），另一个用于传输 终点接收数据
1. 单向流使用发送或接收状态机， 这取决于流类型和端点角色。双向流使用两者 两个端点上的状态机。在大多数情况下，这些状态的使用 无论流是单向的还是双向的，Machines都是相同的。该 打开流的条件稍微复杂一些 流，因为打开发送端或接收端都会导致流 以在两个方向上打开
本节中显示的状态机提供了大量信息。 这个 文档使用流状态描述何时以及如何使用不同类型的规则 的帧，以及不同类型时预期的反应 接收帧。 尽管这些状态机旨在发挥作用 在实施QUIC时，这些状态并不限制 实现。实现可以定义不同的状态机，只要 因为其行为与实现这些的实现一致国家
**注意：在某些情况下，单个事件或操作可能导致转换 穿越多个州。 例如，发送FIN位设置的STREAM， 引起发送流的两个状态转换：从“就绪”状态到 “发送”状态，以及从“发送”状态到“数据已发送”状态**
### 单向流
#### 发送流状态 (Sending Stream States)

      o
       | Create Stream (Sending)
       | Peer Creates Bidirectional Stream
       v
   +-------+
   | Ready | Send RESET_STREAM
   |       |-----------------------.
   +-------+                       |
       |                           |
       | Send STREAM /             |
       |      STREAM_DATA_BLOCKED  |
       v                           |
   +-------+                       |
   | Send  | Send RESET_STREAM     |
   |       |---------------------->|
   +-------+                       |
       |                           |
       | Send STREAM + FIN         |
       v                           v
   +-------+                   +-------+
   | Data  | Send RESET_STREAM | Reset |
   | Sent  |------------------>| Sent  |
   +-------+                   +-------+
       |                           |
       | Recv All ACKs             | Recv ACK
       v                           v
   +-------+                   +-------+
   | Data  |                   | Reset |
   | Recvd |                   | Recvd |
   +-------+                   +-------+


 1. 终结点启动的流的发送部分（类型0 2代表客户机，1和3代表服务器）由应用程序打开。 该 "就绪"状态表示新创建的流能够从 应用程序。 流数据可能会在此状态下缓冲，以准备 发送。
 2. 发送第一个STREAM或STREAM_DATA_BLOCKED帧会导致 流进入“发送”状态。 实现可以选择延迟 向流分配流ID，直到所述流发送所述第一STREAM帧为止，以及 进入该状态，这可以允许更好的流优先化。
 3. 由对等方发起的双向流的发送部分（类型0表示 服务器，类型1表示客户端）在接收部分 被创建。
 4. 在“发送”状态下，端点发送--并根据需要重新发送-- STREAM帧中流数据。 端点遵守设置的流量控制限制 并继续接受和处理MAX_STREAM_DATA帧。 安 处于“发送”状态的端点将生成STREAM_DATA_BLOCKED帧，如果 通过流流量控制限制阻止发送
 5. 在应用程序指示所有流数据都已发送并且STREAM 发送包含FIN位的帧时，流的发送部分进入 "数据已发送"状态。 从此状态开始，端点仅重新传输流数据 视需要而定。 端点不需要检查流控制限制或发送 处于此状态的流的STREAM_DATA_BLOCKED帧。 最大流数据帧 直到对等体接收到最终流偏移。终点 可以安全地忽略从其对等方接收的任何MAX_STREAM_DATA帧 在这种状态下流动
 6. 成功确认所有流数据后， 流进入“数据接收”状态，这是一种终止状态
 7. 应用程序从"就绪"、"发送"或"数据已发送"中的任一状态 可以发信号通知它希望放弃流数据的传输。或者， 端点可以从其对等体接收STOP_SENDING帧。 在任何一种情况下， 端点发送RESET_STREAM帧，该帧使数据流进入 "重置发送"状态。
 8. 端点可以发送RESET_STREAM作为提及流的第一帧; 这使得该流的发送部分打开 转换到“重置已发送”状态。
 9. 一旦包含RESET_STREAM的数据包被确认，发送部分 进入“复位接收”状态，这是一种终止状态。

 #### 接收流状态( Receiving Stream States)

流的一部分的状态，该流 从对等体接收数据。 流镜像的接收部分的状态 在对等端处仅流的发送部分的一些状态。 该 流的接收部分不跟踪发送部分上的状态 例如“就绪”状态。 相反，流的接收部分 跟踪数据向应用程序的传递，其中一些传递无法观察到 由发送者执行。


       o
       | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
       | Create Bidirectional Stream (Sending)
       | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
       | Create Higher-Numbered Stream
       v
   +-------+
   | Recv  | Recv RESET_STREAM
   |       |-----------------------.
   +-------+                       |
       |                           |
       | Recv STREAM + FIN         |
       v                           |
   +-------+                       |
   | Size  | Recv RESET_STREAM     |
   | Known |---------------------->|
   +-------+                       |
       |                           |
       | Recv All Data             |
       v                           v
   +-------+ Recv RESET_STREAM +-------+
   | Data  |--- (optional) --->| Reset |
   | Recvd |  Recv All Data    | Recvd |
   +-------+<-- (optional) ----+-------+
       |                           |
       | App Read All Data         | App Read Reset
       v                           v
   +-------+                   +-------+
   | Data  |                   | Reset |
   | Read  |                   | Read  |
   +-------+                   +-------+


1. 由对等体发起的流的接收部分（类型1和3用于客户端， 或对于服务器为0和2）在第一个STREAM，STREAM_DATA_BLOCKED， 或者接收到用于该流的RESET_STREAM帧。 对于双向流 由对等体发起，收到MAX_STREAM_DATA或STOP_SENDING帧 流的发送部分也创建接收部分。 初始状态 用于流的接收部分的是"Recv"。
2. 对于双向流，接收部分在以下情况下进入“Recv”状态 由端点发起的发送部分（对于客户端，类型为0 1表示服务器）进入“就绪”状态。
3. 当MAX_STREAM_DATA或STOP_SENDING 从对等体接收到该流的帧。 接收最大流数据 未打开流的帧指示远程对等体已打开 流，且正在提供流控制信用。 接收STOP_SENDING帧，用于 未打开的流指示远程对等体不再希望接收 此流上的数据。 帧可能在STREAM之前到达，或者 STREAM_DATA_BLOCKED帧（如果数据包丢失或重新排序）。
4. 在创建流之前，所有具有较低编号的相同类型的流 数据流ID必须被创造出来。 这可确保流的创建顺序为 在两个端点上一致。
5. 在"Recv"状态下，端点接收STREAM和STREAM_DATA_BLOCKED 帧。 传入的数据将被缓冲，并可按正确的顺序重新组装 以便传送到应用程序。 随着数据被应用程序使用， 缓冲区空间可用时，端点将MAX_STREAM_DATA帧发送到 允许对等体发送更多数据。
6. 接收到带有FIN位的STREAM帧时，流的最终大小为 已知;见第4.5节。 然后，流的接收部分进入 “尺寸已知”状态。 在此状态下，端点不再需要发送 最大流数据帧;它只接收流数据的任何重传。
7. 一旦接收到流的所有数据，接收方将输入 “数据接收”状态。 这可能是接收相同STREAM的结果 导致转换为“大小已知”的帧。 在所有数据 接收时，可以将流的任何STREAM或STREAM_DATA_BLOCKED帧 丢弃。
8. "数据接收"状态持续，直到流数据已传送到 应用程序。 一旦流数据被传送，流进入"数据 读"状态，这是一种终端状态。
9. 在“接收”或“大小已知”状态下接收RESET_STREAM帧会导致 流以进入“重置接收”状态。 这可能会导致 流数据到要中断的应用程序。
10. 有可能所有的流数据都已接收，当 接收到RESET_STREAM（即，处于"数据接收"状态）。 同样，它也是 接收到RESET_STREAM后，剩余流数据可能到达 帧（"重置接收"状态）。 实现可以自由地管理这一点 它选择的情况。
11. 发送RESET_STREAM意味着端点无法保证 流数据;然而，不要求不传送流数据 如果接收到RESET_STREAM。 An implementation MAY interrupt delivery of 流数据，丢弃任何未使用的数据，并发出收到 重置流。 在以下情况下，RESET_STREAM信号可能会被抑制或阻止： 流数据被完全接收并且被缓冲以由 应用程序。 如果RESET_STREAM被禁止，则 数据流保持在"数据接收"状态。
12. 一旦应用接收到指示流 被重置，则流的接收部分转换为“重置读取” 状态，这是一种终结状态。

#### 允许的帧类型(Permitted Frame Types)
1. 流的发送方只发送三种帧类型，它们会影响 在发送器或接收器处的流：流（第19.8节）， 数据流阻塞（第19.13节）和重置数据流
2. 发送方不得从终端状态（“数据接收”）发送任何这些帧 或“复位接收”）。 发送方不得发送STREAM或STREAM_DATA_BLOCKED帧 对于处于“Reset Sent”状态或任何终端状态的流-即，在 发送RESET_STREAM帧。 接收器可以接收这三个中的任何一个 任何状态的帧，因为数据包可能延迟传送 带着他们。
3. 流的接收方发送MAX_STREAM_DATA帧 （第19.10节）和STOP_SENDING帧（第19.5节）。
4. 接收器仅在“接收”状态下发送MAX_STREAM_DATA帧。 一种接收器， 可以在未收到STOP_SENDING帧的任何状态下发送该帧。 RESET_STREAM帧-即，除了“复位接收”或“复位读取”之外的状态。 但是，在“数据”中发送STOP_SENDING帧几乎没有什么价值 接收”状态，因为已经接收到所有流数据。 发送者可以接收 这两种类型的帧中的任何一种由于延迟传送而处于任何状态 数据包。

### 双向流状态(Bidirectional Stream States)
双向流由发送部分和接收部分组成。 实现可以将双向流的状态表示为复合 发送和接收流状态。 最简单的模型表示流 当发送或接收部分处于非终端状态时，显示为“打开”，并且 当发送和接收流都处于终止状态时为“关闭”。

表2显示了双向流的更复杂的映射 与HTTP/2中定义的流状态松散对应的状态 [HTTP2]. 这表明发送或接收时的多个状态 流的部分被映射到相同的复合状态。 注意这只是 这种映射的一种可能性;这种映射要求数据 在转换到“关闭”或“半关闭”状态之前确认。

Sending Part 发送部件 								Receiving Part 接收部件 								Composite State 复合状态
No Stream / Ready 无数据流/就绪 						No Stream / Recv (*1) 无数据流/接收（*1） 				idle 闲置
Ready / Send / Data Sent 就绪/发送/数据已发送 			Recv / Size Known 接收/已知尺寸 						open 开放
Ready / Send / Data Sent 就绪/发送/数据已发送 			Data Recvd / Data Read 数据接收/数据读取 				half-closed (remote) 半闭（远程）
Ready / Send / Data Sent 就绪/发送/数据已发送 			Reset Recvd / Reset Read 复位接收/复位读取 			half-closed (remote) 半闭（远程）
Data Recvd 接收数据 									Recv / Size Known 接收/已知尺寸 						half-closed (local) 半封闭（局部）
Reset Sent / Reset Recvd 重置发送/重置接收 			Recv / Size Known 接收/已知尺寸 						half-closed (local) 半封闭（局部）
Reset Sent / Reset Recvd 重置发送/重置接收 			Data Recvd / Data Read 数据接收/数据读取 				closed 封闭的
Reset Sent / Reset Recvd 重置发送/重置接收 			Reset Recvd / Reset Read 复位接收/复位读取 			closed 封闭的
Data Recvd 接收数据 									Data Recvd / Data Read 数据接收/数据读取 				closed 封闭的
Data Recvd 接收数据 									Reset Recvd / Reset Read 复位接收/复位读取 			closed 封闭的


### 请求的状态转换(Solicited State Transitions)
如果应用程序对它在 流时，它可以中止阅读流并指定应用程序错误代码。
1. 如果流处于“Recv”或“Size Known”状态，则传输应该 发送STOP_SENDING帧以提示关闭中的流，从而发出信号 相反的方向。 这通常表示接收应用程序 不再阅读从流接收的数据，但这不是保证 输入数据将被忽略。
2. 发送STOP_SENDING帧后收到的STREAM帧仍会计数 连接和流流量控制，即使这些帧可以 接收后丢弃。
3. STOP_SENDING帧请求接收端点发送RESET_STREAM 框架。 An endpoint that receives a STOP_SENDING frame MUST send a RESET_STREAM 帧，如果流处于"就绪"或"发送"状态。 如果流位于 "Data Sent" state  the endpoint MAY defer sending the RESET_STREAM frame until 确认或宣布包含未完成数据的分组丢失。 如果 any outstanding data is declared lost  the endpoint SHOULD send a RESET_STREAM 帧而不是重传数据。
4. 端点应该将错误代码从STOP_SENDING帧复制到 RESET_STREAM帧，但它可以使用任何应用程序错误代码。 安 发送STOP_SENDING帧的端点可以忽略任何 随后为该流接收的RESET_STREAM帧。
5. STOP_SENDING SHOULD only be sent for a stream that has not been reset by the 同伴。STOP_SENDING对于"接收"或"已知大小"中的流最有用 状态。
6. 如果数据包 包含先前STOP_SENDING的消息丢失。 然而，一旦所有流 数据或RESET_STREAM帧已接收到该流--即 流处于“Recv”或“Size Known”以外的任何状态--发送 STOP_SENDING帧是不必要的。
7. 希望终止双向流的两个方向的端点 可以通过发送RESET_STREAM帧终止一个方向，并且可以 通过发送STOP_SENDING，鼓励在相反方向立即终止 框架。

## 流量控制(Flow Control)
接收方需要限制需要缓冲的数据量，以 以防止快速发送者压倒他们或恶意发送者 消耗大量存储器。 使接收器能够限制内存 对于连接的承诺，流是单独和 将连接作为一个整体。 QUIC接收器控制最大数量的 发送器可以在任何时间在流上以及跨所有流发送数据， 如章节所述4.1以及4.2。
类似地，为了限制连接中的并发性，QUIC端点控制 其对等方可以启动的最大累积流数，如 described in Section 4.6. 
在CRYPTO帧中发送的数据不以与流相同的方式进行流控制 数据。 QUIC依赖于加密协议实现来避免 excessive buffering of data; see [QUIC-TLS].要避免在 multiple layers  QUIC implementations SHOULD provide an interface for the 加密协议实现来传达其缓冲限制。

### 数据流控制(Data Flow Control)

QUIC采用基于限制的流控制方案，其中接收器通告 它准备在给定流上接收的总字节数限制，或 整个连接。 这导致QUIC中有两个级别的数据流控制：
1. 流流量控制，防止单个流消耗整个 接收缓冲区，通过限制可以接收的数据量 在每个流上发送。
2. 连接流控制，防止发送方的流量超过接收方的流量 通过限制流数据的总字节数来限制连接的缓冲区容量 在所有流上的STREAM帧中发送。
发送者不得发送超过任一限制的数据。

1. 接收机通过传输参数为所有流设置初始限制 握手期间（第7.4节）。 随后，接收器发送 MAX_STREAM_DATA帧（第19.10节）或MAX_DATA帧 （第19.9节）向发送者通告更大的限额。
2. 接收方可以通过发送 具有相应流ID的MAX_STREAM_DATA帧。MAX_STREAM_DATA帧 指示流的最大绝对字节偏移量。接收机可以 基于所述当前偏移来确定要通告的所述流控制偏移 在该流上消耗的数据。
3. 接收方可以通过发送MAX_DATA来通告连接的更大限制 帧，它指示绝对字节偏移量之和的最大值 所有流。 接收方维护在所有 流，用于检查通告连接的冲突，或 流数据限制。接收机可以确定最大数据限制为 基于在所有流上消耗的字节的总和来通告。
4. 一旦接收方通告了连接或流的限制，它就不是 错误，但较小的限制没有任何效果。
5. 接收器必须关闭带有FLOW_CONTROL_ERROR类型错误的连接，如果 发送方违反所通告的连接或流数据限制;见 有关错误处理的详细信息，请参见第11节。
6. 发送方必须忽略任何不增加的MAX_STREAM_DATA或MAX_DATA帧 流量控制极限。
7. 如果发送方已发送的数据达到限制，则将无法发送新数据 并且被认为是阻塞的。 发送方应发送STREAM_DATA_BLOCKED或 DATA_BLOCKED帧，向接收器指示它有数据要写入，但 被流量控制限制阻塞。 如果发件人被阻止的时间超过 空闲超时（第10.1节），接收器可能会关闭连接 即使当发送者具有可用于传输的数据时。 为了保持 连接关闭时，受流量控制限制的发送方应该 在没有数据时定期发送STREAM_DATA_BLOCKED或DATA_BLOCKED帧 在传输中引发ACK的数据包。

### 增加流量控制限制(Increasing Flow Control Limits)

实现决定何时在MAX_STREAM_DATA中公布信用以及公布多少信用 和MAX_DATA帧，但本节提供了一些注意事项。
1. 为了避免阻塞发送方，接收方可以发送MAX_STREAM_DATA或MAX_DATA 在往返过程中多次发送帧，或者尽早发送以留出时间 用于帧的丢失和随后的恢复。
2. 控制帧会增加连接开销。因此，频繁发送 MAX_STREAM_DATA和MAX_DATA帧具有较小的变化是不可取的。 在 另一方面，如果更新频率较低，则限制的增量较大 必须避免阻塞发送者，这需要在 接收器。 在资源承诺和开销之间有一个权衡 当确定通告多大的限制时。
3. 接收机可以使用自动调谐机制来调谐频率和 基于往返时间估计和速率 接收应用程序使用数据，类似于普通TCP 实现。 作为优化，端点可以发送与以下内容相关的帧 仅在有其他帧要发送时进行流量控制，以确保 控制不会导致发送额外的分组。
4. 被阻止的发送方不需要发送STREAM_DATA_BLOCKED或DATA_BLOCKED 帧。Therefore  a receiver MUST NOT wait for a STREAM_DATA_BLOCKED or 在发送MAX_STREAM_DATA或MAX_DATA帧之前的DATA_BLOCKED帧;这样做 可能导致发送者在连接的其余部分被阻塞。就算 发送方发送这些帧，等待它们将导致发送方 至少在整个往返中被阻塞。
5. 当发件人在被阻止后收到信用额度时，它可能能够发送 响应数据量大，造成短期拥塞;见 Section 7.7 of [QUIC-RECOVERY] for a discussion of how a sender can avoid this 拥塞。

### 流量控制性能(Flow Control Performance)
如果端点无法确保其对等方始终具有可用的流控制 大于此节点上的带宽延迟积的信用 连接时，其接收吞吐量将受到流量控制的限制。
数据包丢失可能导致接收缓冲区出现间隙，从而阻止应用程序 消耗数据并释放接收缓冲器空间。
及时发送流量控制限制的更新可以提高性能。 仅发送数据包来提供流量控制更新可以增加网络 负载并对性能产生不利影响。发送流量控制更新沿着 诸如ACK帧之类的其它帧降低了这些更新的成本。

### 处理流取消(Handling Stream Cancellation)

端点最终需要就具有的流控制信用量达成一致 已在每个流上使用，以便能够说明 连接级流量控制。
在收到RESET_STREAM帧时，端点将断开 匹配流并忽略到达该流的其它数据。
RESET_STREAM突然终止流的一个方向。 对于双向 流，RESET_STREAM对相反方向的数据流没有影响。 两者 端点必须为未终止的流维护流控制状态 直到该方向进入终止状态。

### 流最终大小(Stream Final Size)

最终大小是由消耗的流量控制信用量 流。 假设流中的每个连续字节都发送了一次，则 最终大小是发送的字节数。 一般来说，这是一个更高的 比在流上发送的具有最大偏移量的字节的偏移量大，或者为零 如果没有发送字节。
发送方总是将流的最终大小通知给接收方 无论流如何被终止。最终大小是以下各项的总和 带有FIN标志的STREAM帧的Offset和Length字段，请注意 这些字段可以是隐式的。 或者，将 RESET_STREAM帧携带此值。这保证了两个端点都同意 取决于发送方在该流上消耗了多少流量控制信用。
对象的接收部分被调用时，端点将知道流的最终大小 流进入“大小已知”或“重置接收”状态（第3节）。 该 接收方必须使用流的最终大小来说明发送的所有字节 流在其连接级流控制器中。
端点不得在流上发送等于或超过最终大小的数据。
一旦知道了流的最终大小，它就不能改变。 如果重置流或 接收指示流的最终大小的改变的STREAM帧， an endpoint SHOULD respond with an error of type FINAL_SIZE_ERROR; see Section 11 for details on error handling. A receiver SHOULD treat 接收到的数据达到或超过最终大小，作为类型错误 FINAL_SIZE_ERROR，即使在流关闭之后。 生成这些错误不是 强制，因为要求端点生成这些错误还意味着 端点需要保持封闭流的最终大小状态， 这可能意味着国家的重大承诺。

### 控制并发(Controlling Concurrency)

终结点限制对等方可以打开的传入流的累计数量。仅流ID小于 (max_streams * 4 + first_stream_id_of_type) 的流可被打开; see Table 1. 初始 在传输参数中设置限制;见 Section 18.2.后续限制将使用 MAX_STREAMS frames; see Section 19.11.单独的限制适用于 单向和双向流。
如果接收到max_streams传输参数或MAX_STREAMS帧时 值大于 2_60  变长度整数的最大流ID; see Section 16. 如果接收到任何一个，则必须立即关闭连接，并显示类型为TRANSPORT_PARAMETER_ERROR的错误，
如果违规值是在传输参数中接收的，则为FRAME_ENCODING_ERROR类型
端点不得超过其对等端设置的限制。 一种端点，其 接收到流ID超过其发送限制的帧时必须处理 这是类型为STREAM_LIMIT_ERROR的连接错误;见第11节 了解有关错误处理的详细信息
一旦接收机使用MAX_STREAMS帧通告流限制， 通告较小的限制没有效果。 MAX_STREAMS帧不 提高流量限制必须被忽略。
与流和连接流控制一样，本文档将实现 决定何时以及多少个流应该被通告 通过MAX_STREAMS发送到对等体。 实现可以选择增加限制，因为 流被关闭，以大致保持对等体可用的流的数量 始终如一。
由于对等体的限制而无法打开新流的端点应该 发送STREAMS_BLOCKED帧（19.14节）。 这个信号是 被认为对调试有用。端点不能等待接收此消息 信号，因为这样做将意味着 对等体将至少在整个往返过程中被阻塞，并且可能 如果对等方选择不发送STREAMS_BLOCKED帧，则无限期地发送。

## 连接(Connections)

QUIC连接是客户机和服务器之间的共享状态。
1. 每个连接都以握手阶段开始，在此期间，两个端点 使用所述密码握手协议建立共享秘密 [QUIC-TLS]并协商应用协议。握手 （第7节）确认两个终点愿意进行沟通 （第8.1节）并为连接建立参数 （第7.4节）。
2. 应用程序协议可以在与的握手阶段使用连接 一些局限性。 0-RTT允许应用程序数据由客户端在 从所述服务器接收响应。 但是，0-RTT不提供保护 against replay attacks; see Section 9.2 of [QUIC-TLS]. 服务器还可以发送 在客户端接收到最终的加密 握手消息，这些消息允许它确认 客户。 这些功能允许应用协议提供以下选项 以一些安全保证换取减少的等待时间。
3. 使用连接ID（第5.1节）允许连接迁移到 新的网络路径，既可以作为端点的直接选择，也可以在 中间箱中的变化。 第9节描述了安全和 与迁移相关的隐私问题。
4. 对于不再需要的连接，有几种方法可以 客户端和服务器终止连接，如第10节所述。

### 连接ID(Connection ID)

1. 每个连接拥有一组连接标识符或连接ID， 其中每一个都可以标识该连接。 连接ID是独立的 按终点选择;每个端点选择其对等体 用途。
2. 连接ID的主要功能是确保地址的更改 在较低协议层（UDP、IP）不会导致QUIC的数据包 连接被传递到错误的端点。 每个端点选择 连接ID使用特定于实现的（可能 特定于部署的）方法，该方法将允许具有该连接ID的数据包 被路由回端点并被端点识别 收据。
3. 使用多个连接ID，以便端点可以发送无法发送的数据包 被观察者识别为用于相同的连接，而没有 来自端点的协作;参见第9.5节。
4. 连接ID不得包含任何可供外部观察员使用的信息（即不与发行者合作的人）进行关联 将它们与同一连接的其他连接ID进行比较。 作为一个平凡的例子， 这意味着相同的连接ID不能在相同的连接上发布超过一次。
5. 具有长报头的数据包包括源连接ID和目标 连接ID字段。 这些字段用于为新的 连接;详见第7.2节。
6. 具有短报头的数据包（第17.3节）仅包括目的地 连接ID并省略显式长度。 目标的长度 连接ID字段应是端点已知的。 终点使用 基于连接ID进行路由的负载平衡器可能与负载一致 均衡器对连接ID的固定长度进行协商，或者对编码方案达成一致。 固定部分可以对显式长度进行编码，这允许整个 连接ID的长度可以变化，但负载平衡器仍将使用它。
7. 版本协商（第17.2.1节）数据包回显连接ID 由客户端选择，以确保向客户端的正确路由以及 证明该数据包是对客户端发送的数据包的响应。
8. 当不需要连接ID时，可以使用零长度连接ID 路由到正确的端点。但是，同一个上的多路复用连接 使用零长度连接ID时的本地IP地址和端口将导致 存在对等连接迁移、NAT重新绑定和客户端时的故障 端口复用。一个端点不得对多个端点使用相同的IP地址和端口 具有零长度连接ID的并发连接，除非它是确定的 这些协议特征没有被使用。
9. 当端点使用非零长度的连接ID时，它需要确保 对等体具有连接ID供应，可从中选择发送到的信息包 终点。 这些连接ID由端点使用 新连接ID帧（第19.15节）。

#### 发布连接ID(Issuing Connection IDs)

1. 每个连接ID都有一个关联的序列号，以帮助检测 NEW_CONNECTION_ID或RETIRE_CONNECTION_ID帧引用相同的值。 该 端点发出的初始连接ID在源连接ID中发送 握手期间长数据包报头的字段（第17.2节）。 该 初始连接ID的序列号为0。 如果首选地址 传输参数时，提供的连接ID的序列号 是1。
2. 其他连接ID使用NEW_CONNECTION_ID与对等方通信 框架（第19.15节）。 每个新发布的序列号 连接ID必须增加1。 客户端为其选择的连接ID 它发送的第一个“目标连接ID”字段以及任何连接ID 由重试分组提供的序列号不被分配。
3. 当端点发出连接ID时，它必须接受携带此ID的数据包 连接持续期间或直到其对等方失效为止的连接ID 通过RETIRE_CONNECTION_ID帧发送连接ID (Section 19.16). 已发出和未发出的连接ID 退役的被视为现役;任何活动的连接ID都可用于 任何时间、任何分组类型的当前连接。 这包括 服务器通过preferred_address传输发出的连接ID 参数。
4. 端点应该确保它的对等体有足够数量的可用和未使用的连接ID。端点使用active_connection_id_limit传输参数通告它们愿意维护的活动连接ID的数量。端点提供的连接ID不能超过对等体的限制。如果NEW_CONNECTION_ID帧还要求通过在Retire Prior To字段中包含足够大的值来收回任何超出的连接ID，则端点可以发送暂时超出对等体限制的连接ID。
5. NEW_CONNECTION_ID帧可能导致端点添加一些活动连接 ID，并根据“之前退休”字段的值退休其他人。 之后 处理NEW_CONNECTION_ID帧并添加和撤消活动连接 如果活动连接ID的数目超过其 active_connection_id_limit传输参数，则端点必须关闭 错误类型为CONNECTION_ID_LIMIT_ERROR的连接。
6. 一个终点应该当对等体退出连接时提供新的连接ID 身份证。 如果端点提供的连接ID少于对等端点提供的连接ID 活动连接ID限制，它五月当它收到一个 具有以前未使用的连接ID的数据包。端点五月限制 为到的每个连接发出的连接ID总数 避免连接ID用完的风险;见第10.3.2节。 安 终点五月还限制连接ID的发布，以减少 它作为对等方维护的每个路径状态，例如路径验证状态 可以通过与发出的连接一样多的路径与它交互 身份证。
7. 启动迁移并需要非零长度连接ID的端点 应该确保其对等体可用的连接ID池允许 对等项在迁移时使用新的连接ID，因为对等项将无法 在池耗尽时响应。
8. 在握手期间选择零长度连接ID的端点 无法发出新的连接ID。长度为零的目标连接ID 字段用于通过任何网络向此类端点发送的所有数据包中 路径。

#### 使用和注销连接ID(Consuming and Retiring Connection IDs)

1. 端点可以将其用于对等方的连接ID更改为另一个可用的 在连接期间的任何时间一个。 端点使用的连接ID 对迁移对等体的响应;更多详情请参见第9.5节。
2. 端点维护一组从其对等方接收到的连接ID，其中包括 其可以在发送分组时使用。 当端点希望删除 连接ID时，它向其对等方发送RETIRE_CONNECTION_ID帧。 发送RETIRE_CONNECTION_ID帧表示连接ID将不 并请求对等体用新的连接ID替换它 使用NEW_CONNECTION_ID帧。
3. 如第9.5节所述，终点限制了 从单个本地地址发送到单个 目的地址。 端点应该在连接ID为否时停用它们 更长时间地使用本地地址或目标地址， 已使用连接ID。
4. 在某些情况下，端点可能需要停止接受以前发出的连接ID。这样的端点可以通过发送具有增加的Retire Prior To字段的NEW_CONNECTION_ID帧来使其对等体停用连接ID。端点应该继续接受先前发出的连接ID，直到它们被对等体撤回。如果端点不能再处理所指示的连接ID，它可以关闭连接。
5. 在收到一个增加的退休之前字段，对等必须停止使用 对应的连接ID，并使用RETIRE_CONNECTION_ID使其失效 在将新提供的连接ID添加到活动连接ID集合之前 连接ID。此顺序允许端点替换所有活动 连接ID，而不存在对等体没有可用连接的可能性 ID，并且不超过对等方在 活动连接标识限制传输参数;见 第18.2节。无法停止使用连接ID 可能导致连接失败，因为发出端点可能 无法继续使用活动连接的连接ID。
6. 一个端点应该限制它已经在本地退出的连接ID的数量，对于这些连接ID，RETIRE_CONNECTION_ID帧还没有被确认。端点应该允许发送和跟踪至少两倍于active_connection_id_limit传输参数值的RETIRE_CONNECTION_ID帧的数量。一个端点一定不能忘记一个连接ID而不使它失效，尽管它可以选择将需要失效的连接ID超过这个限制作为CONNECTION_ID_LIMIT_ERROR类型的连接错误来处理.
7. 端点不应在接收之前发布Retire Previous To字段的更新 RETIRE_CONNECTION_ID帧，这些帧停用由 以前的“以前报废”值。

### 将数据包与连接匹配(Matching Packets to Connections)

1. 传入数据包在接收时进行分类。 数据包可以关联 或者（对于服务器）可能创建新的 连接。
2. 端点尝试将数据包与现有连接相关联。如果分组 具有一个非零长度的目标连接ID，该ID对应于现有的 连接时，QUIC会相应地处理该数据包。注意不止一个 连接ID可以与连接相关联;参见第5.1节。
3. 如果目标连接ID长度为零并且寻址信息 数据包中的地址与端点用于标识 连接ID长度为零的连接时，QUIC会将数据包作为 这种联系。 端点可以只使用目标IP和端口，也可以同时使用两者 源地址和目标地址进行识别，尽管这会使 连接易碎，如第5.1节所述。
4. 端点可以发送无状态重置（第10.3节），用于任何 不能归因于现有连接。无状态重置允许对等方 以更快地识别连接何时变得不可用。
5. 如果与现有连接匹配的数据包 与该连接的状态不一致。 例如，数据包 如果它们指示与的协议版本不同的协议版本，则丢弃 连接，或者如果删除数据包保护不成功 预期密钥可用。
6. 缺少强大完整性保护的无效数据包，如初始、重试 或版本协商，可以丢弃。端点必须生成 连接错误，如果处理这些数据包的内容之前 发现错误，或完全恢复在该处理期间所做的任何更改。

#### 客户端数据包处理(Client Packet Handling)

1. 发送到客户端的有效数据包始终包含目标连接ID 匹配客户端选择的值。 选择接收零长度的客户端 连接ID可以使用本地地址和端口来标识连接。 与现有连接不匹配的数据包-基于目标 连接ID或本地IP地址和端口（如果此值的长度为零）为 丢弃。
2. 由于数据包重新排序或丢失，客户端可能会收到 使用尚未计算密钥加密的连接。客户可以 丢弃这些数据包，或者它可以缓冲它们，以预期后面的数据包 允许它计算密钥。
3. 如果客户端接收到的数据包使用的版本与最初版本不同 则它必须丢弃该数据包。



#### 服务器数据包处理(Server Packet Handling)

1. 如果服务器接收到一个指示不支持版本的数据包，并且该数据包足够大，可以为任何支持的版本发起一个新的连接，则服务器应该发送一个版本协商数据包，如第6.1节所述。服务器可以限制它用版本协商包响应的包的数量。服务器必须丢弃指定不支持版本的较小数据包。
2. 不受支持版本的第一个数据包可以使用不同的语义和 任何版本特定字段的编码。 特别地，不同分组 保护密钥可以用于不同的版本。 不支持的服务器 支持特定版本的用户不太可能能够解密的有效载荷 分组或正确地解释结果。 服务器应响应 版本协商数据包，前提是数据报足够长。
3. 具有受支持版本或没有“版本”字段的数据包将与 使用连接ID的连接，或--用于具有零长度连接的包 ID--本地地址和端口。 这些数据包使用 选择的连接;否则，服务器如下所述继续。
4. 如果数据包是完全符合规范的初始数据包，则 服务器继续进行握手（第7节）。这将使服务器承诺 客户端选择的版本。
5. 如果一个服务器拒绝接受一个新的连接，它应该发送一个初始数据包 包含具有错误代码CONNECTION_REFUSED的CONNECTION_CLOSE帧。
6. 如果数据包是一个0-RTT数据包，服务器可以缓冲有限数量的数据包 预期到迟到的初始分组。客户端无法 在接收服务器响应之前发送握手数据包，因此服务器 应忽略任何此类数据包。
7. 服务器必须在所有其他情况下丢弃传入数据包。

#### 简单负载平衡器的注意事项(Considerations for Simple Load Balancers)

服务器部署可以仅使用源和 目的IP地址和端口。更改客户端的IP地址或端口 可能导致分组被转发到错误的服务器。这样的服务器 部署可以使用以下方法之一实现连接连续性 当客户的地址改变时。
1. 服务器可以使用带外机制将数据包转发到正确的 基于连接ID的服务器。
2. 如果服务器可以使用专用服务器IP地址或端口，而不是 客户端最初连接到的地址，它们可以使用preferred_address 传输参数来请求客户端将连接移动到专用 地址。请注意，客户端可以选择不使用首选地址。
3. 部署中未实现要维护的解决方案的服务器 connection continuity when the client address changes SHOULD indicate that 使用disable_active_migration传输不支持迁移 参数。 disable_active_migration传输参数不禁止 客户机对preferred_address传输执行操作后的连接迁移 参数。
4. 使用这种简单形式的负载平衡的服务器部署必须避免 创建无状态重置oracle;参见第21.11节。

### 连接上的操作(Operations on Connections)

本文件未定义QUIC的API;而是定义了一组 应用程序协议可以依赖的QUIC连接的函数。 安 应用协议可以假设QUIC的实现提供了 包含本节所述操作的界面。 安 设计用于特定应用协议实现可以 仅提供由该协议使用的那些操作。
在实现客户端角色时，应用程序协议可以：
1. 打开一个连接，该连接将开始中所述的交换第七节; 
2. 当服务器接受或拒绝早期数据时被通知。
实现服务器角色时，应用程序协议可以：
1. 侦听传入连接，这将为中所述的交换做准备 第7节; 
2. 如果支持早期数据，则在发送给客户端的TLS恢复票据中嵌入应用控制的数据;以及
3. 如果支持早期数据，则从检索应用程序控制的数据 客户端的恢复票证，并基于此接受或拒绝早期数据 信息。

无论扮演哪种角色，应用程序协议都可以：
1. 配置每个的初始允许流数的最小值 type，在传输参数中传递（7.4节）; 
2. 通过设置流控制限制来控制接收缓冲器的资源分配 用于流和连接; 
3. 确定握手是否成功完成或仍在进行中; 
4. 通过生成PING帧，防止连接自动关闭 （第19.2节）或请求传输发送附加帧 在空闲超时到期之前（第10.1节）;以及
5. 立即关闭连接（第10.2节）。

## 版本协商(Version Negotiation)
版本协商允许服务器指示它不支持 客户端使用的版本。 服务器在中发送版本协商数据包 对可能发起新连接的每个分组的响应;见 详情见第5.2节。
客户端发送的第一个数据包的大小将决定服务器是否 发送版本协商数据包。支持多个QUIC版本的客户端 应该确保他们发送的第一个UDP数据报的大小为 它们支持的所有版本的最小数据报大小（使用PADDING帧） （第19.1节）。这可确保服务器在出现 是相互支持的版本。服务器可能不发送版本协商 数据包，如果它接收的数据报小于中指定的最小大小 不同的版本参见第14.1节。


### 发送版本协商包(Sending Version Negotiation Packets)

1. 如果服务器不接受客户端选择的版本，则服务器以版本协商分组进行响应;参见第17.2.1节。这包括服务器将接受的版本列表。端点不得发送版本协商数据包以响应接收到版本协商数据包。
2. 此系统允许服务器处理不支持版本的数据包，而无需 保持状态。 尽管初始分组或版本协商 作为响应发送的数据包可能丢失，客户端将发送新的数据包 直到它成功地接收到响应或者它放弃连接尝试。
3. 服务器可以限制它发送的版本协商包的数量。 为 实例中，能够将数据包识别为0-RTT的服务器可能选择不识别 发送版本协商数据包以响应0-RTT数据包， 期望它最终将接收到初始分组。

### 处理版本协商包(Handling Version Negotiation Packets)

1. 版本协商数据包旨在允许将功能 在未来定义，允许QUIC协商要使用的QUIC版本 寻找联系。 未来的标准跟踪规范可能会改变 支持多个QUIC版本的实现对版本做出反应 响应于尝试建立 连接使用此版本
2. 仅支持此版本QUIC的客户端必须放弃当前 连接尝试，如果它接收到版本协商数据包，则使用 但有两个例外。客户端必须丢弃任何版本协商数据包 如果它已经接收并成功处理了任何其他数据包，包括 早期版本协商数据包。客户端必须放弃版本协商 列出客户端选择的QUIC版本的数据包。
3. 如何进行版本协商留待将来定义 标准跟踪规范。 特别是，今后的工作将 确保抵抗版本降级攻击的鲁棒性;见 第21.12节.

### 使用保留版本(Using Reserved Versions)

1. 对于将来使用新版本的服务器，客户端需要正确 处理不支持的版本。某些版本号（0x？一个？一个？一个？a，定义见 Section 15) are reserved for inclusion in fields that contain version 数字。
2. 端点可以向未知或不支持的任何字段添加保留版本 版本被忽略以测试对等体正确地忽略该值。为 实例中，端点可以在版本协商中包含保留版本 数据包;参见第17.2.1节。端点可以发送带有保留 版本来测试对等项是否正确丢弃了数据包

## 加密和传输握手(Cryptographic and Transport Handshake)

QUIC依赖于组合的加密和传输握手来最小化 连接建立延迟。 QUIC使用CRYPTO帧（第19.6节） 以发送加密握手。 此中定义的QUIC版本 文档标识为0x00000001，并使用TLS，如中所述[快速TLS]; 不同的QUIC版本可以指示不同的加密 正在使用握手协议。
QUIC提供了加密握手数据的可靠、有序的传递。QUIC数据包保护用于尽可能多地加密握手协议。加密握手必须提供以下属性：

a.  认证密钥交换，其中
 1. 服务器总是经过身份验证的
 2. 客户端是可选的身份验证，
 3. 每个连接产生不同且不相关的密钥，并且
 4. 密钥材料可用于0-RTT和1-RTT的分组保护 数据包。
b. 两个端点的传输参数的值的认证交换， 和机密性保护（请参见 第7.4节）。
c. 应用程序协议的身份验证协商（TLS使用 应用层协议协商（ALPN）[ALPN]）。

CRYPTO帧可以在不同的分组号空间中发送 (Section 12.3). CRYPTO帧用于确保有序的偏移量 密码握手数据传递在每个分组号中从零开始 空间。
图4显示了简化的握手以及数据包和帧的交换 用于推进握手。 应用程序数据在 在可能的情况下启用握手，用星号（“*”）表示。 一旦 握手完成后，端点能够自由地交换应用程序数据。

Client                                               Server

Initial (CRYPTO)
0-RTT (*)              ---------->
                                           Initial (CRYPTO)
                                         Handshake (CRYPTO)
                       <----------                1-RTT (*)
Handshake (CRYPTO)
1-RTT (*)              ---------->
                       <----------   1-RTT (HANDSHAKE_DONE)

1-RTT                  <=========>                    1-RTT

简化的QUIC握手
端点可以使用握手期间发送的数据包来测试显式 拥塞通知（ECN）支持;参见第13.4节。端点验证 通过观察ACK帧是否确认第一个 它发送的分组携带ECN计数，如第13.4.2节所述。
端点必须明确地协商应用程序协议。这避免了对正在使用的协议存在分歧的情况。

### 握手流示例(Example Handshake Flows)

1. 有关TLS如何与QUIC集成的详细信息，请参见[QUIC-TLS]，但 这里提供了一些例子。 此交换的扩展，以支持 客户端地址验证如第8.1.2节所示。
2. 完成任何地址验证交换后， 密码握手用于就密码密钥达成一致。 该 加密握手在初始化（第17.2.2节）和握手中执行 （第17.2.4节）数据包。
3. 图5概述了1-RTT握手。每行显示一个QUIC数据包，首先显示数据包类型和数据包编号，然后显示这些数据包中通常包含的帧。例如，第一分组是初始类型的，具有分组号0，并且包含携带ClientHello的CRYPTO帧。
4. 多个QUIC数据包--甚至是不同的数据包类型--可以合并成 单个UDP数据报;参见第12.2节。结果，这个握手 可以由少至四个UDP数据报组成，也可以由任意多个UDP数据报组成（受 协议固有的限制，如拥塞控制和 反放大）。 例如，服务器的第一个航班包含Initial 分组、握手分组和1-RTT分组中的“0.5-RTT数据”。

Client                                                  Server

Initial[0]: CRYPTO[CH] ->

                                 Initial[0]: CRYPTO[SH] ACK[0]
                       Handshake[0]: CRYPTO[EE  CERT  CV  FIN]
                                 <- 1-RTT[0]: STREAM[1  "..."]

Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN]  ACK[0]
1-RTT[0]: STREAM[0  "..."]  ACK[0] ->

                                          Handshake[1]: ACK[0]
         <- 1-RTT[1]: HANDSHAKE_DONE  STREAM[3  "..."]  ACK[0]


图6显示了使用0-RTT握手的连接示例 和0-RTT数据的单个分组。请注意，如中所述 第12.3节，服务器确认1-RTT数据包中的0-RTT数据，以及 客户端在相同的分组编号空间中发送1-RTT分组。

Client                                                  Server

Initial[0]: CRYPTO[CH]
0-RTT[0]: STREAM[0  "..."] ->

                                 Initial[0]: CRYPTO[SH] ACK[0]
                                  Handshake[0] CRYPTO[EE  FIN]
                          <- 1-RTT[0]: STREAM[1  "..."] ACK[0]

Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN]  ACK[0]
1-RTT[1]: STREAM[0  "..."] ACK[0] ->

                                          Handshake[1]: ACK[0]
         <- 1-RTT[1]: HANDSHAKE_DONE  STREAM[3  "..."]  ACK[1]




### 协商连接ID(Negotiating Connection IDs)

1. 连接ID用于确保数据包路由的一致性，如中所述 Section 5.1. 长标头包含两个连接ID：目的地 连接ID由数据包的接收方选择，用于提供 一致的路由;源连接ID用于设置目标 对等方使用的连接ID。
2. 在握手过程中，使用带有长报头（第17.2节）的数据包 以建立由两个端点使用的连接ID。每个端点都使用 源连接ID字段指定在中使用的连接ID 发送给它们的数据包的目标连接ID字段。加工后 第一个初始数据包，每个端点设置目的连接ID 它发送的后续数据包中的一个字段，该字段的值为源连接ID 它收到的字段。
3. 当客户端发送初始数据包时，如果该客户端以前未收到 初始或重试数据包时，客户端将填充目标 具有不可预测值的连接ID字段。 此目标连接ID 长度必须至少为8个字节。 直到从服务器接收到分组， 客户端必须在所有信息包上使用相同的目的连接ID值 这种联系。
4. 发送的第一个初始数据包中的目标连接ID字段 客户端用于确定初始分组的分组保护密钥。 这些 在接收到重试分组之后密钥改变;见第5.2节属于[快速TLS]。
5. 客户端使用其选择的值填充“源连接ID”字段 并设置源连接ID长度字段以指示长度。
6. 0-RTT  第一次飞行中的分组使用相同的目的地连接ID 源连接ID值作为客户端的第一个初始数据包。
7. 在第一次从服务器接收到Initial或Retry数据包时，客户端使用 服务器提供的源连接ID作为目标连接ID 用于后续分组，包括任何0-RTT分组。 这意味着客户端 可能必须更改它在“目标连接ID”中设置的连接ID 字段在连接建立期间重复两次：一次响应重试数据包 一次响应于来自服务器的初始分组。一旦客户端 从服务器接收到有效的初始数据包，则必须丢弃任何后续 它在该连接上接收的具有不同源连接ID的数据包
8. 客户端必须更改其用于发送数据包的目标连接ID 仅响应于第一个接收到的初始或重试分组。 服务器必须 根据第一个设置它用于发送数据包的目标连接ID 接收到初始数据包。对目标连接ID的任何进一步更改 仅当值取自NEW_CONNECTION_ID帧时才允许;如果 如果后续初始数据包包含不同的源连接ID，则必须 被丢弃。 这避免了否则可能导致的不可预测的结果 从具有不同源的多个初始分组的无状态处理 连接ID。
9. 端点发送的目标连接ID可以随 连接的生存期，尤其是响应连接迁移时 （第9节）;详见第5.1.1节。

### 验证连接ID(Authenticating Connection IDs)

1. 每个端点在握手期间对连接ID所做的选择是 通过在传输参数中包括所有值来认证;见 Section 7.4.这可确保用于的所有连接ID 握手也通过密码握手来认证。
2. 每个端点都包含源连接ID字段的值，该字段来自 它在初始源连接ID传输中发送的第一个初始数据包 参数;参见第18.2节。服务器包括 接收到的第一个初始数据包的目标连接ID字段 原始目的地连接标识传输参数中的客户端;如果 服务器发送了一个重试数据包，这是指接收到的第一个初始数据包 在发送重试分组之前。如果它发送重试数据包，服务器还 包括重试数据包中的源连接ID字段 retry_source_connection_id传输参数。
3. 对等方为这些传输参数提供的值必须与 端点在“目标连接ID”和“源连接ID”字段中使用的值 发送（和接收，对于服务器）的初始数据包。终点必须 验证所接收的传输参数与所接收的连接ID值匹配。 在传输参数中包括连接ID值并验证它们 可确保攻击者无法影响连接ID的选择 通过注入携带攻击者选择的连接的数据包成功连接 握手时的ID。
4. 端点必须处理缺少initial_source_connection_id传输的情况 参数，或者缺少 服务器中的original_destination_connection_id传输参数作为 TRANSPORT_PARAMETER_ERROR类型的连接错误。
5. 端点必须将以下内容视为类型为的连接错误 传输参数错误或方案违反：
服务器中缺少retry_source_connection_id传输参数 在接收到重试数据包后，
未重试时存在retry_source_connection_id传输参数 收到数据包，或
在这些传输参数中从对等体接收的值之间的不匹配 以及在对应的目标或源连接ID中发送的值 初始分组的字段。
6. 如果选择零长度连接ID，则相应的传输 参数包含在零长度值中。
7. 显示了完整握手中使用的连接ID（DCID=目标连接ID，SCID=源连接ID）。示出了初始分组的交换，加上包括在握手期间建立的连接ID的1-RTT分组的稍后交换。
Client                                                  Server

Initial: DCID=S1  SCID=C1 ->
                                  <- Initial: DCID=C1  SCID=S3
                             ...
1-RTT: DCID=S3 ->
                                             <- 1-RTT: DCID=C1

8. 在握手中使用连接ID
Client                                                  Server

Initial: DCID=S1  SCID=C1 ->
                                    <- Retry: DCID=C1  SCID=S2
Initial: DCID=S2  SCID=C1 ->
                                  <- Initial: DCID=C1  SCID=S3
                             ...
1-RTT: DCID=S3 ->
                                             <- 1-RTT: DCID=C1


在具有重试的握手中使用连接ID

8. 当握手不包括Retry（图7）时，服务器设置 原始目的地连接ID设置为S1（请注意，此值由 客户端）和初始源连接标识发送到S3。在本例中，服务器 不包括retry_source_connection_id传输参数。
9. 当握手包含Retry（图8）时，服务器设置 将原始目的地连接标识添加到S1，将重试源连接标识添加到S2， 和初始源连接标识发送到S3。

### 运输参数(Transport Parameters)

1. 在连接建立期间，两个端点都进行身份验证声明 它们的传输参数。 终点必须符合 每个参数定义的限制;每个参数的描述 包括用于其处理的规则。
2. 传输参数是由每个用户单方面做出的声明 终点。 每个端点都可以独立选择传输参数的值 它的同伴选择的值。
3. 传输参数的编码详见 Section 18. 
4. QUIC在加密握手中包括编码的传输参数。 握手完成后，对等体声明的传输参数为 可用。 每个端点验证其对等端点提供的值。
5. 中包含了每个已定义传输参数的定义 Section 18.2. 
6. 端点必须将接收到的具有无效值的传输参数视为 TRANSPORT_PARAMETER_ERROR类型的连接错误。
7. 一个终点不得在给定传输中多次发送参数 参数扩展。 一个终点应该处理重复运输收据 参数作为TRANSPORT_PARAMETER_ERROR类型的连接错误。
8. 终结点使用传输参数来验证 握手期间的连接ID;参见第7.3节。
9. ALPN（参见[ALPN]）允许客户端提供多个应用程序 协议。的传输参数 客户端在握手期间包括应用于所有应用协议， 客户报价。应用程序协议可以推荐传输值 参数，例如初始流量控制限制。然而，应用程序， 对传输参数的值设置约束的协议可以使其 客户端不可能提供多个应用程序协议，如果这些 约束冲突。

#### 0-RTT的传输参数值(Values of Transport Parameters for 0-RTT)

1. 使用0-RTT取决于客户端和服务器使用的协议参数 是从先前的连接协商的。 要启用0-RTT，端点存储 服务器传输参数的值及其任何会话票证 在连接上接收。 端点还存储所需的任何信息 应用协议或加密握手;见第4.6节属于[快速TLS]。 尝试时将使用存储的传输参数值 0-RTT使用会话票证。
2. 记住的传输参数将应用于新连接，直到握手 完成并且客户端开始发送1-RTT分组。 一旦握手 完成后，客户端将使用在中建立的传输参数 握手。 并非所有传输参数都会被记住，因为有些参数不适用于 或者它们对0-RTT的使用没有影响。
3. 新传输参数的定义（第7.4.2节）必须指定存储0-RTT的传输参数是强制的、可选的还是禁止的。客户端不需要存储它无法处理的传输参数。
4. 客户端不得使用以下参数的记忆值： 确认延迟指数、最大确认延迟、初始源连接ID、 原始目的地连接ID，优选地址， 重试源连接标识和无状态重置令牌。客户端必须使用 在握手中使用服务器的新值;如果服务器不提供新的 值，则使用默认值。
5. 尝试发送0-RTT数据的客户端必须记住服务器使用的所有其他传输参数。服务器可以记住这些传输参数，或者可以存储票证中值的完整性保护副本，并在接受0-RTT数据时恢复信息。服务器使用传输参数来确定是否接受0-RTT数据。
6. 如果服务器接受0-RTT数据，则服务器不得减少任何 限制或更改客户端可能违反的任何值 0-RTT数据。 特别是，接受0-RTT数据的服务器不得设置 以下参数的值（第18.2节） 其小于参数的记忆值。
active_connection_id_limit 活动连接ID限制
initial_max_data 初始最大数据
initial_max_stream_data_bidi_local 初始_最大_流_数据_双向_本地
initial_max_stream_data_bidi_remote 初始_最大_流_数据_双向_远程
initial_max_stream_data_uni 初始最大流数据单位
initial_max_streams_bidi 初始_最大_流_bidi
initial_max_streams_uni 初始_最大_流_uni 
7. 忽略某些传输参数或将其设置为零值可能会导致 0-RTT数据已启用但不可用。 适用的传输子集 允许发送应用程序数据的参数应设置为非零值 0-RTT的值。 这包括初始_最大_数据和（1） 初始_最大_流_双向和初始_最大_流_数据_双向_远程或（2） 初始最大流单位和初始最大流数据单位。
8. 服务器可能为流提供较大的初始流流量控制限制 而不是客户端在发送0-RTT时应用的记忆值。 一次 握手完成后，客户端更新流控制 使用更新的值限制所有发送流 初始最大流数据双向远程和初始最大流数据单向。
9. 服务器可以存储和恢复先前发送的max_idle_timeout、max_udp_payload_size和disable_active_migration参数值，如果选择较小的值，则拒绝0-RTT。在接受0-RTT数据的同时降低这些参数的值可能会降低连接的性能。具体而言，降低max_udp_payload_size可能导致丢弃数据包，从而导致性能比直接拒绝0-RTT数据更差。
10. 服务器必须拒绝0-RTT数据，如果传输的恢复值 不支持参数。
11. 当在0-RTT分组中发送帧时，客户端必须仅使用记忆的传输参数;重要的是，它不能使用从服务器的更新传输参数或从在1-RTT分组中接收的帧获知的更新值。来自握手的传输参数的更新值仅适用于1-RTT分组。例如，来自记忆的传输参数的流控制限制应用于所有0-RTT分组，即使那些值通过握手或通过在1-RTT分组中发送的帧而增加。服务器可以将在0-RTT中使用更新的传输参数视为PROTOCOL_VIOLATION类型的连接错误。

#### 新传输参数(New Transport Parameters)

1. 新的传输参数可用于协商新的协议行为。端点必须忽略它不支持的传输参数.因此，缺少传输参数将禁用使用该参数协商的任何可选协议特征。如第18.1节所述，保留一些标识符以执行此要求。
2. 不理解传输参数的客户端可以丢弃该参数 在后续连接上尝试0-RTT。但是，如果客户端添加了对 已丢弃的传输参数，则有可能违反 传输参数建立，如果它尝试0-RTT。新传输参数 可以通过设置最保守的默认值来避免此问题。 客户端可以通过记住所有参数来避免此问题，即使这些参数不是 目前支持。可以根据中的规则注册新的传输参数 第22.3节。

### 加密消息缓冲(Cryptographic Message Buffering)

1. 实现需要维护乱序接收的CRYPTO数据的缓冲区。 因为没有CRYPTO帧的流控制，端点可以 可能迫使其对等体缓冲无限数量的数据。
2. 实现必须支持缓冲至少4096字节的接收数据 乱序CRYPTO帧。端点可以选择允许更多数据 在握手期间被缓冲。握手期间的较大限制可能允许 以便交换更大的密钥或凭证。端点的缓冲区大小 不需要在连接的寿命期间保持恒定。
3. 在握手过程中无法缓冲CRYPTO帧可能会导致 连接失败。如果在握手过程中超出了端点的缓冲区，则 可以临时扩展其缓冲区以完成握手。如果端点 不扩展其缓冲区，则它必须使用 CRYPTO缓冲区超出错误代码。
4. 一旦握手完成，如果端点不能缓冲CRYPTO帧中的所有数据，它可以丢弃该CRYPTO帧和将来接收到的所有CRYPTO帧，或者它可以关闭具有CRYPTO_BUFFER_EXCEEDED错误代码的连接。包含丢弃的CRYPTO帧的数据包必须被确认，因为即使CRYPTO帧被丢弃，数据包也已经被传输接收和处理。

## 地址验证(Address Validation)

1. 地址验证可确保端点不能用于通信 放大攻击。 在这种攻击中，数据包被发送到服务器，并带有 标识受害者的欺骗源地址信息。 如果服务器 生成更多或更大的数据包作为对该数据包的响应，攻击者可以 使用服务器向受害者发送超出其能力范围的数据 靠它自己。
2. 对放大攻击的主要防御措施是验证对等体是否能够在其声明的传输地址接收数据包。因此，在接收到来自一个尚未验证的地址的数据包后，端点必须将其发送到未验证地址的数据量限制为从该地址接收到的数据量的三倍。这种对响应大小的限制称为抗扩增限制。
3. 地址验证在连接建立期间执行（请参见 第8.1节）和连接迁移期间（请参见 第8.2节）。

### 连接建立期间的地址验证(Address Validation during Connection Establishment)

1. 连接建立隐式地为两者提供地址验证 终点。 特别地，接收用握手密钥保护的分组 确认对等项已成功处理初始数据包。 曾经 端点已成功处理来自对等方的握手数据包，则它可以 则认为对等地址已被确认。
2. 此外，如果对等体地址有效，则端点可以认为该对等体地址有效 使用端点选择的连接ID，并且连接ID包含 至少64位的熵。
3. 对于客户端，是其第一个 初始数据包允许它将服务器地址作为 成功处理任何分组。来自服务器的初始数据包为 使用从此值派生的密钥进行保护（请参见第5.2节属于[快速TLS]）.或者，服务器在Version中回显该值 协商包（第六节）或包含在完整性标签中 在重试数据包（第5.8节属于[快速TLS]）. 
4. 在验证客户端地址之前，服务器发送的字节数不得超过其接收到的字节数的三倍。这限制了任何可以使用欺骗源地址进行的放大攻击的幅度。为了避免在地址验证之前放大，服务器必须计算在唯一归属于单个连接的数据报中接收到的所有有效负载字节。这包括包含成功处理的数据包的数据报和包含全部丢弃的数据包的数据报。
5. 客户端必须确保包含初始数据包的UDP数据报具有 至少1200字节的有效载荷，必要时添加PADDING帧。 发送填充数据报的客户端允许服务器 在完成地址验证之前发送更多数据。
6. 如果客户端不发送其他初始数据包或握手数据包，则服务器丢失初始数据包或握手数据包可能导致死锁。当服务器达到其反放大限制并且客户端已收到其发送的所有数据的确认时，可能会发生死锁。在这种情况下，当客户端没有理由发送额外的数据包时，服务器将无法发送更多的数据，因为它没有验证客户端的地址。为了防止这种死锁，客户端必须在探测超时（PTO）时发送分组;参见[快速恢复]的第6.2节。具体来说，如果客户端没有握手密钥，则必须在包含至少1200字节的UDP数据报中发送初始数据包，否则发送握手数据包。
7. 服务器可能希望在启动 加密握手。QUIC在初始数据包中使用令牌来提供 在完成握手之前进行地址验证。此令牌将传送到 在连接建立期间使用重试数据包（请参见 第8.1.2节）或使用NEW_TOKEN帧在以前的连接中（请参见 第8.1.3节）。
8. 除了在地址验证之前施加的发送限制之外，服务器还 它们可以发送的内容也受到拥塞设置的限制的约束 控制器。 客户端仅受拥塞控制器的约束。

#### 令牌构造(Token Construction)

在NEW_TOKEN帧或重试数据包中发送的令牌必须以允许服务器识别它是如何提供给客户端的方式构造。这些令牌在同一字段中携带，但需要来自服务器的不同处理。

#### 使用重试数据包进行地址验证(Address Validation Using Retry Packets)


在接收到客户端的初始化数据包时，服务器可以请求地址 通过发送重试分组（第17.2.5节）包含令牌。这个 记号必须由客户端在其为此发送的所有初始数据包中重复 在接收到重试数据包后，连接。
响应于处理包含所提供的令牌的初始分组 在一个Retry包中，服务器不能再发送一个Retry包;它只能拒绝 连接或允许其继续。
只要攻击者无法为生成有效令牌 它自己的地址（参见第8.1.4节），并且客户端能够返回 该令牌，则它向服务器证明它接收到该令牌。
服务器还可以使用"重试"数据包来推迟的状态和处理开销 连接建立。要求服务器提供不同的 连接ID，以及原始目标连接ID传输 parameter defined in Section 18.2  forces the server to 证明其或与之合作的实体收到了原件 来自客户端的初始数据包。提供不同的连接ID还将授予 服务器对后续分组如何被路由进行一些控制。这个可以用 以将连接定向到不同的服务器实例。
如果服务器收到包含无效重试标记但 否则有效，则它知道客户端不会接受另一个重试令牌。 服务器可以丢弃这样的数据包，并允许客户端超时到 检测握手失败，但这可能会对 客户。 Instead  the server SHOULD immediately close (Section 10.2) 连接出现INVALID_TOKEN错误。 请注意，服务器没有 已在此时为连接建立任何状态，因此不会进入 关闭期间。
显示重试数据包用法的流程如所示图九(带重试的握手示例)。
Client                                                  Server

Initial[0]: CRYPTO[CH] ->

                                                <- Retry+Token

Initial+Token[1]: CRYPTO[CH] ->

                                 Initial[0]: CRYPTO[SH] ACK[1]
                       Handshake[0]: CRYPTO[EE  CERT  CV  FIN]
                                 <- 1-RTT[0]: STREAM[1  "..."]



#### 未来连接的地址验证(Address Validation for Future Connections)

1. 服务器可以在一个过程中向客户端提供地址验证令牌 可用于后续连接的连接。 地址验证为 对于0-RTT尤其重要，因为服务器可能会发送重要的 响应于0-RTT数据发送到客户端的数据量。
2. 服务器使用NEW_TOKEN帧（19.7节）向客户端提供地址验证令牌，该令牌可用于验证将来的连接。在将来的连接中，客户端将此令牌包含在初始数据包中以提供地址验证。客户端必须在其发送的所有初始数据包中包含令牌，除非重试操作将令牌替换为新的令牌。客户端不得使用重试中提供的令牌进行将来的连接。服务器可以丢弃任何没有携带预期令牌的初始数据包。
3. 与为“重试”数据包创建的令牌不同（后者会立即使用）， 在NEW_TOKEN帧中发送的令牌可以在一段时间后使用 时间已经过去了。 因此，一个令牌应该有一个过期时间，它可以 可以是显式的到期时间或发布的时间戳 用于动态计算到期时间。 服务器可以存储 到期时间或将其以加密形式包含在令牌中。
4. 使用NEW_TOKEN发出的令牌不得包含允许观察者将值链接到发出该令牌的连接的信息。例如，它不能包含以前的连接ID或寻址信息，除非这些值经过加密。服务器必须确保它发送的每个NEW_TOKEN帧在所有客户端都是唯一的，除了那些用来修复先前发送的NEW_TOKEN帧丢失的帧。允许服务器区分来自Retry和NEW_TOKEN的令牌的信息可由服务器以外的实体访问。
5. 客户端端口号在两个不同的 连接;因此，验证端口不太可能成功。
6. 在NEW_TOKEN帧中接收的令牌适用于 连接被认为是权威的（例如，服务器名称包含在 证书）。 当连接到客户端为其保留 适用且未使用的令牌，则应将该令牌包含在 其初始分组。 包括令牌可能允许服务器验证 客户端地址，而无需额外的往返行程。 客户端不得包括 不适用于它所连接到的服务器的令牌，除非 客户端知道发布令牌的服务器和服务器 客户端正在连接到它们，它们共同管理令牌。 客户端可以使用 以前连接到服务器任何令牌。
7. 令牌允许服务器将颁发令牌的连接与使用令牌的任何连接之间的活动关联起来。想要中断与服务器的身份连续性的客户端可以丢弃使用NEW_TOKEN帧提供的令牌。相比之下，在重试数据包中获得的令牌必须在连接尝试期间立即使用，并且不能在随后的连接尝试中使用。
8. 客户端不应该为不同的连接尝试重用NEW_TOKEN帧中的令牌。重用令牌允许网络路径上的实体链接连接;参见第9.5节。
9. 客户端可能在单个连接上接收多个令牌。 除了 防止可链接性，任何令牌都可以用于任何连接尝试。 服务器可以发送额外的令牌来启用地址验证 多次连接尝试或替换可能无效的旧令牌。 对于客户端，这种不确定性意味着发送最近未使用的令牌 最有可能有效。 尽管保存和使用较旧的令牌没有 负面后果，客户端可能会认为较旧的令牌不太可能 对于服务器的地址验证是有用的。
10. 当服务器接收到带有地址验证令牌的初始数据包时，它必须尝试验证该令牌，除非它已经完成了地址验证。如果令牌是无效的，那么服务器应该继续，就好像客户端没有一个有效的地址，包括潜在地发送一个重试包.服务器可以区分NEW_TOKEN帧和Retry包提供的令牌（参见8.1.1节），并且可以更严格地验证后者。如果验证成功，服务器应该允许握手继续进行.**将客户端视为未经验证而不是 丢弃数据包的原因是客户端可能在 使用NEW_TOKEN帧返回上一个连接，如果服务器已丢失 状态时，它可能根本无法验证令牌，从而导致连接 如果数据包被丢弃，则失败**
11. 在无状态设计中，服务器可以使用加密和身份验证的令牌 将信息传递给客户端，服务器稍后可以将其恢复并用于 验证客户端地址。 令牌未集成到加密 握手，因此它们没有被认证。 例如，客户端可能是 能够重用令牌。 为了避免利用此属性的攻击，服务器 可以将令牌的使用限制为仅验证客户端所需的信息 地址。
12. 客户端可以使用在一个连接上获得的令牌进行任何连接尝试 使用相同的版本。 选择要使用的令牌时，客户端无需 考虑正在尝试的连接的其他属性，包括 可能的应用协议、会话票证或其他 连接属性。

#### 地址验证令牌完整性(Address Validation Token Integrity)

1. 地址验证标记必须是难以猜测的. 包括随机的 令牌中具有至少128位熵的值将是足够的，但是 这取决于服务器记住它发送给客户机的值。
2. 基于令牌的方案允许服务器卸载与 验证给客户端。 要使此设计工作，令牌必须由 防止客户修改或伪造的完整性保护。 无 完整性保护，恶意客户端可以生成或猜测 将被服务器接受的令牌。 只有服务器需要访问 令牌的完整性保护密钥。
3. 标记不需要一个定义良好的格式，因为 生成令牌的服务器也会使用令牌。在重试数据包中发送的令牌 应包括允许服务器验证源IP的信息 客户端分组中的地址和端口保持不变。
4. 在NEW_TOKEN帧中发送的令牌必须包含允许服务器验证客户端IP地址自令牌发出时起未发生更改的信息。服务器可以使用NEW_TOKEN帧中的令牌来决定不发送重试数据包，即使客户端地址已更改。如果客户端的IP地址已经改变，服务器必须遵守反放大限制;参见第8节。请注意，在存在NAT的情况下，此要求可能不足以保护共享NAT的其他主机免受放大攻击。
5. 攻击者可以重放令牌，将服务器用作DDoS攻击的放大器。至 防止此类攻击、服务器必须确保令牌的重播 阻止或限制。服务器应该确保在重试数据包中发送的令牌 仅在短时间内被接受，因为它们会立即被客户端返回。 NEW_TOKEN帧中提供的令牌（第19.7节）需要 有效期更长，但不应被多次接受。服务器是 鼓励在可能的情况下只允许代币使用一次;代币五月包括 关于客户端的附加信息以进一步缩小适用性或重用。

### 路径验证(Path Validation)

1. 在连接迁移期间，两个对等方都使用路径验证 (see第9节）来验证地址改变后的可达性。 在路径验证中，端点测试特定本地 地址和特定对等地址，其中地址是以下内容的2元组 IP地址和端口。
2. 路径验证测试在路径上发送到对等方的数据包 由该对等体接收。路径验证用于确保收到的数据包 来自迁移对等点的源地址不携带欺骗的源地址。
3. 路径验证不验证对等方是否可以在返回方向上发送。 确认不能用于返回路径验证，因为它们包含 熵不足，可能被欺骗。终点独立确定 路径的每个方向上的可达性以及因此返回可达性可以 只能由对等体建立。
4. 任何一个端点都可以随时使用路径验证。 例如，一个 端点可以检查对等体在 平静的时期。
5. 路径验证不是作为NAT穿越机制设计的。尽管 此处描述的机制可能对创建NAT绑定有效 支持NAT穿越，则期望一个端点能够 接收数据包，而无需首先在该路径上发送数据包。有效的NAT 遍历需要额外的同步机制，而这些机制尚未提供 给你。
6. 端点可以在PATH_CHALLENGE和PATH_RESPONSE中包含其他帧 用于路径验证的帧。 特别地，端点可以包括PADDING 带有PATH_CHALLENGE帧的帧，用于路径最大传输单元发现 （PMTUD）;参见第14.2.1节。端点还可以包含自己的PATH_CHALLENGE 发送PATH_RESPONSE帧时的帧。
7. 端点将新的连接ID用于从新的本地地址发送的探测; see Section 9.5. 当探测新路径时，端点可以 确保其对等方有未使用的连接ID可用于 回应。在相同的地址中发送NEW_CONNECTION_ID和PATH_CHALLENGE帧 数据包，如果对等体的active_connection_id_limit允许，则确保未使用的 当发送响应时，连接ID将可用于对等体。
8. 端点可以选择同时探测多条路径。数量 用于探测的同时路径受到额外连接数量的限制 ID，因为每个新的本地地址用于 探测器需要以前未使用的连接ID。

#### 正在启动路径验证(Initiating Path Validation)

1. 为了启动路径验证，端点发送包含以下内容的PATH_CHALLENGE帧 路径上的不可预测有效载荷将被验证。
2. 一个端点可以发送多个PATH_CHALLENGE帧以防止数据包丢失。然而，一个端点不应该在一个数据包中发送多个PATH_CHALLENGE帧。
3. 端点不应该比发送初始数据包更频繁地用包含PATH_CHALLENGE帧的数据包探测新路径。这确保了连接迁移在新路径上的负载不会比建立新连接更大。
4. 端点必须在每个PATH_CHALLENGE帧中使用不可预测的数据，以便 它可以将对等体的响应与对应的PATH_CHALLENGE相关联。
5. 端点必须将包含PATH_CHALLENGE帧的数据报扩展到至少允许的最小最大数据报大小1200字节，除非路径的反放大限制不允许发送此大小的数据报。发送这种大小的UDP数据报确保了从端点到对等体的网络路径可以用于QUIC;参见第14节。
6. 当端点由于反放大限制而无法将数据报大小扩展到1200字节时，将不会验证路径MTU。为了确保路径MTU足够大，端点必须通过发送至少1200字节的数据报中的PATH_CHALLENGE帧来执行第二次路径验证。可以在成功接收到PATH_RESPONSE之后，或者当在发送较大数据报的路径上已经接收到足够的字节而不会导致超过反放大限制时，执行该附加验证。
7. 与扩展数据报的其他情况不同，端点不得丢弃 当数据报包含PATH_CHALLENGE或 路径_响应。

#### 路径验证响应(Path Validation Responses)

1. 在接收PATH_CHALLENGE帧时，端点必须通过回显 包含在PATH_RESPONSE帧中的PATH_CHALLENGE帧中的数据。 安 端点不得延迟包含PATH_RESPONSE的数据包的传输 帧，除非受到拥塞控制的约束。
2. 路径响应帧必须在PATH_CHALLENGE的网络路径上发送 帧已收到。 这可以确保只有对等项的路径验证成功 如果路径在两个方向上都起作用。 这项要求不得是 由启动路径验证的端点强制执行，因为这将启用 对移徙的攻击;见第9.3.3节。
3. 端点必须将包含PATH_RESPONSE帧的数据报扩展到 最小为1200字节的最小允许最大数据报大小。这验证了 该路径能够在两个方向上传送这种大小的数据报。 但是，端点不得扩展包含PATH_RESPONSE的数据报 如果结果数据超过反扩增极限。预计这将 仅当接收到的PATH_CHALLENGE不是在扩展数据报中发送时才发生。
4. 一个端点不得发送多个PATH_RESPONSE帧来响应一个PATH_RESPONSE帧 路径_挑战帧;参见第13.3节。 同行是 应根据需要发送更多PATH_CHALLENGE帧以调用其他 路径响应帧。

#### 路径验证成功(Successful Path Validation)

1. 当收到包含以下内容的PATH_RESPONSE帧时，路径验证成功 在先前PATH_CHALLENGE帧中发送的数据。 路径响应 在任何网络路径上接收到的帧都会验证 已发送路径挑战。
2. 如果端点在未扩展到至少1200个字节的数据报中发送PATH_CHALLENGE帧，并且如果对它的响应验证了对等地址，则验证路径，但不验证路径MTU。因此，端点现在可以发送已接收数据量的三倍以上。但是，端点必须使用扩展的数据报启动另一个路径验证，以验证该路径是否支持所需的MTU。
3. 接收包含PATH_CHALLENGE帧的数据包的确认 验证不充分，因为确认可能被恶意的 同伴。

#### 路径验证失败(Failed Path Validation)

1. 仅当端点尝试验证路径时，路径验证才会失败 放弃其验证路径的尝试。
2. 终点应该基于定时器放弃路径验证。设置此选项时 计时器，则需要注意新路径可能具有更长的 往返时间比原来长。 的较大值的三倍 当前PTO或新路径的PTO（根据定义使用kInitialRtt 在[快速恢复]）是推荐。
3. 此超时允许多个PTO在路径出现故障之前过期 验证，以避免丢失单个PATH_CHALLENGE或PATH_RESPONSE帧 不会导致路径验证失败。
4. 请注意，端点可能会在新的 路径，但路径需要包含适当数据的PATH_RESPONSE帧 验证成功。
5. 当端点放弃路径验证时，它确定该路径不可用。这并不一定意味着连接失败--端点可以根据需要继续通过其他路径发送数据包。如果没有可用的路径，端点可以等待新路径变为可用或关闭连接。没有有效网络路径的端点可以使用NO_VIABLE_PATH连接错误来通知这一点，请注意，这仅在网络路径存在但不支持所需MTU时才可能（第14节）。
6. 路径验证可能会因其他原因而放弃 失败。这种情况主要发生在以下情况：连接迁移到新路径 在旧路径上的路径验证正在进行时发起。

## 连接迁移(Connection Migration)

1. 连接ID的使用允许连接在端点更改后继续存在 地址（IP地址和端口），例如由 端点迁移到新网络。 本节通过以下方式介绍该过程 端点将其迁移到新地址。
2. QUIC的设计依赖于端点为 握手的持续时间。 一个终点不得启动连接迁移 在确认握手之前，如中所定义第4.1.2节属于[快速TLS]。
3. 如果对等体发送了disable_active_migration传输参数，则端点也不能发送分组（包括探测分组;参见第9.1节）从不同的本地地址到对等体在握手期间使用的地址，除非端点已经对来自对等体的preferred_address传输参数起作用。如果对等体违反此要求，则端点必须丢弃该路径上的传入数据包而不生成无状态重置，或者继续进行路径验证并允许对等体迁移。生成无状态重置或关闭连接将允许网络中的第三方通过欺骗或以其他方式操纵观察到的流量来导致连接关闭。
4. 并非所有对等地址的改变都是有意的或主动的迁移。对等体可能会遇到NAT重新绑定：由于中间盒（通常是NAT）为流分配新的输出端口或甚至新的输出IP地址而导致的地址改变。端点必须执行路径验证（8.2节），如果它检测到对等体地址的任何变化，除非它以前已经验证过该地址.
5. 当一个端点没有有效的路径来发送数据包时，它可以丢弃 连接状态。 能够进行连接迁移的终结点可以等待 在丢弃连接状态之前变为可用的新路径。
6. 本文档限制将连接迁移到新的客户端地址，但第9.6节中所述的情况除外。客户端负责启动所有迁移。服务器不会向客户端地址发送非探测包（参见9.1节），直到它们看到来自该地址的非探测包。如果客户端接收到来自未知服务器地址的数据包，客户端必须丢弃这些数据包。

### 探索新路径(Probing a New Path)

1. 一个终点五月使用路径探测从新本地地址的对等方可达性 确认（第8.2节），然后将连接迁移到新的 本地地址。 路径验证失败仅意味着新路径未被 可用于此连接。 验证路径失败不会导致 连接结束，除非没有可用的有效替代路径。
2. 路径挑战、路径响应、新连接ID和填充帧是 “探测帧”，所有其它帧是“非探测帧”。 一包 仅包含探测帧的分组是“探测分组”，而包含 任何其它帧是“非探测分组”。

### 正在启动连接迁移(Initiating Connection Migration)

1. 端点可以通过发送数据包将连接迁移到新的本地地址 包含来自该地址的非探测帧。
2. 每个端点在连接建立期间验证其对等方的地址。 因此，迁移端点可向其对等体发送，知道该对等体 愿意在对等体的当前地址接收。因此，端点可以迁移 而不首先验证对等体的地址。
3. 为了在新路径上建立可达性，端点启动路径 验证（8.2节）。端点可以推迟路径 直到对等体将下一个非探测帧发送到其新的 地址。
4. 迁移时，新路径可能不支持端点的当前发送 率。因此，端点重置其拥塞控制器和RTT估计， as described in Section 9.4. 
5. 新路径可能不具有相同的ECN能力。因此，终点 确认ECN能力，如第13.4节所述。

### 响应连接迁移(Responding to Connection Migration)

1. 从新对等地址接收包含非探测帧的分组 指示对等体已迁移到该地址。
2. 如果接收方允许迁移，则它必须向新的对等体地址发送后续分组，并且如果验证尚未进行，则必须发起路径验证（8.2节）以验证对等体对地址的所有权。如果接收者没有来自对等体的未使用的连接ID，则它将不能在新路径上发送任何东西，直到对等体提供一个连接ID;参见第9.5节。
3. 端点仅更改其发送数据包的目标地址以响应 最高编号的非探测分组。这可确保端点不会 在接收到重新排序的数据包的情况下，将数据包发送到旧的对等地址 数据包。
4. 端点可以向未经验证的对等地址发送数据，但必须保护 防范第9.3.1节所述的潜在攻击，以及 第9.3.2条. 端点可以跳过对等地址的验证，如果 最近有人看到过这个地址。 特别是，如果终结点返回到 先前验证的路径在检测到某种形式的虚假迁移之后， 跳过地址验证并恢复丢失检测和拥塞状态 可以降低攻击对性能的影响。
5. 在更改了向其发送非探测数据包的地址之后，端点 可以放弃对其他地址的任何路径验证。
6. 从新的对等地址接收数据包可能是NAT的结果 在对等体处重新绑定。验证新的客户端地址后，服务器应该发送新地址 验证令牌（第8节）发送给客户端。

#### 对等地址欺骗(Peer Address Spoofing)

1. 可能是对等项欺骗其源地址以导致端点 向不愿意的主机发送过量数据。 如果端点发送 比欺骗对等体的数据多得多的数据，连接迁移可能 用于扩大攻击者可以生成的数据量，以攻击 受害者。
2. 如9.3节所述，端点需要验证对等体的新地址，以确认对等体拥有新地址。在对等体的地址被认为有效之前，端点限制它发送到该地址的数据量;参见第8节。如果没有此限制，端点可能会被用于对毫无戒心的受害者进行拒绝服务攻击。
3. 如果端点如上所述跳过对等地址的验证，则会跳过 不需要限制其发送速率。

#### 路径上地址欺骗(On-Path Address Spoofing)

1. 路径上的攻击者可以通过复制和 转发带有欺骗地址的数据包，使其在 原始数据包。 具有欺骗地址的数据包将被视为来自 迁移连接，而原始数据包将被视为副本， 掉了。虚假迁移后，源地址验证将失败 因为源地址处的实体不具有必要的 用于读取或响应所发送的PATH_CHALLENGE帧的加密密钥 即使它想。
2. 为了防止连接由于这种虚假迁移而失败，当新的对等地址验证失败时，端点必须恢复使用最后验证的对等地址。另外，从合法对等地址接收到具有较高分组号的分组将触发另一连接迁移。这将导致放弃虚假迁移的地址验证，从而包含由注入单个数据包的攻击者发起的迁移。
3. 如果端点没有关于最后验证的对等地址的状态，则必须关闭它 通过丢弃所有连接状态来静默连接。这将产生新的 连接上的分组被一般地处理。例如，一个端点 可以发送无状态重置以响应任何进一步的传入数据包。

#### 离路数据包转发(Off-Path Packet Forwarding)

1. 可以观察数据包的非路径攻击者可能会转发正版 分组到端点。 如果复制的分组在真实分组之前到达， 这将表现为NAT重新绑定。 任何真正的数据包都将作为 复制。 如果攻击者能够继续转发数据包，则可能 能够导致经由攻击者迁移到路径。 这说明攻击者 在路径上，使其能够观察或丢弃所有后续数据包。
2. 这种类型的攻击依赖于攻击者使用的路径具有大约 与端点之间的直接路径具有相同的特性。 这次袭击是 如果发送相对较少的分组或者如果同时发生分组丢失，则更可靠 与这次未遂袭击有关。
3. 在原始路径上接收到的非探测数据包会增加最大值 接收到的分组号将使端点移回到该路径。 在此路径上引发数据包会增加攻击 不成功。 因此，缓解此攻击依赖于触发 分组的交换。
4. 作为对明显迁移的响应，端点必须验证先前 使用PATH_CHALLENGE帧的活动路径。 这会导致发送新的 数据包。如果路径不再可行，验证尝试 将超时并失败;如果路径可行但不再需要，则 验证将成功，但只会导致探测数据包在 路径。
5. 在活动路径上接收到PATH_CHALLENGE的端点应该发送一个非探测数据包作为响应。如果非探测数据包在攻击者复制之前到达，这将导致连接被迁移回原始路径。任何后续迁移到另一个路径的操作都将重新启动整个过程。
6. 这种辩护是不完美的，但这并不被认为是一个严重的问题。如果 经过攻击的路径确实比原始路径快 尝试使用该原始路径，则无法区分 攻击和路由改进。
7. 端点还可以使用启发式来改进对此类 攻击。 例如，如果数据包最近 在旧路径上接收;类似地，在IPv6路径上重新绑定是罕见的。 终点 还可以查找重复的分组。 相反，连接ID的更改为 更有可能表示有意迁移而不是攻击。

### 丢包检测与拥塞控制(Loss Detection and Congestion Control)

1. 丢包检测与拥塞控制
2. 在确认对等体对其新地址的所有权时，端点必须 立即重置拥塞控制器和往返时间估计器 初始值的新途径（参见附录答三以及 B.3款的[快速恢复]）除非对等方的唯一更改 address是其端口号。 因为仅端口更改通常是 NAT重新绑定或其他中间盒活动的端点五月而是保留了 其拥塞控制状态和往返估计而不是 恢复到初始值。 在保持拥塞控制状态的情况下， 在新路径上使用与旧路径基本不同的 特征，发送方可能会过于积极地传输，直到拥塞 控制器和RTT估计器已经适配。通常，实现是 建议在新路径上使用以前的值时要小心。
3. 当端点发送数据时，接收方可能会出现明显的重新排序 并且在迁移期间从/向多个地址进行探测，因为这两个 得到的路径可能具有不同的往返时间。 数据包的接收器 多个路径仍将发送覆盖所有接收到的分组的ACK帧。
4. 虽然在连接迁移过程中可能会使用多个路径，但是 拥塞控制上下文和单个丢失恢复上下文（如 [快速恢复]）可能是足够的。 例如，端点可能会延迟 切换到新的拥塞控制上下文，直到确认旧的拥塞控制上下文 不再需要路径（如中所述的情况第9.3.3节）. 
5. 发送方可以对探测包进行例外处理，以便 并且不会不适当地使拥塞控制器减少其 发送速率。 当PATH_CHALLENGE为 发送，如果接收到相应的PATH_RESPONSE，则取消。如果 计时器在收到PATH_RESPONSE之前触发，则端点可能会发送新的 PATH_CHALLENGE并重新启动计时器一段更长的时间。 这个计时器 应该按照中所述进行设置第6.2.1节属于[快速恢复]以及不得是 更具攻击性。

### 连接迁移对隐私的影响(Privacy Implications of Connection Migration)

1. 在多个网络路径上使用稳定的连接ID将允许被动 观察器来关联这些路径之间的活动。 移动的端点 可能不希望使它们的活动与任何实体相关 ，因此从发送时使用不同的连接ID 不同的本地地址，如第5.1节所述。 为了这个 端点需要确保它们提供连接ID不会被 由任何其他实体链接。
2. 在任何时间，终点五月更改它们传输的目标连接ID 将更改为尚未在其他路径上使用的值。
3. 一个终点不得从多个本地发送时重用连接ID 地址--例如，在按中所述启动连接迁移时 第9.2节或者当探测新的网络路径时 第9.1节。
4. 类似地，端点不得发送到多个时重用连接ID 一个目的地址。 由于网络更改超出其控制范围 对等体，端点可能会从具有相同地址的新的源地址接收数据包 目标连接ID字段值，在这种情况下，它五月继续使用 当前连接ID与新的远程地址，同时仍从 相同的本地地址。
5. 有关连接ID重用的这些要求仅适用于 数据包，因为路径的无意更改而连接ID没有更改 有可能。 例如，在网络不活动一段时间后，NAT重新绑定 可能导致当客户端恢复发送时在新路径上发送分组。 An endpoint responds to such an event as described in Section 9.3. 
6. 对每个新的数据包上双向发送的数据包使用不同的连接ID 网络路径不需要使用连接ID将数据包从 不同网络路径上的相同连接。 顶盖保护确保 分组号不能用于关联活动。 这并不妨碍 分组的其他属性（例如定时和大小）被用于 关联活动。
7. 一个端点不应该发起与一个请求零长度连接ID的对等体的迁移，因为新路径上的流量可能与旧路径上的流量毫无关联。如果服务器能够将具有零长度连接ID的分组关联到正确的连接，则意味着服务器正在使用其他信息来解复用分组。例如，服务器可以为每个客户机提供唯一的地址--例如，使用HTTP替代服务[ALTSVC]。可能允许分组在多个网络路径上正确路由的信息还将允许那些路径上的活动被除对等体之外的实体链接。
8. 客户端可能希望通过切换到新的连接ID来减少可链接性， 源UDP端口或IP地址（请参见[RFC8981]） 不活动的时间。 更改它从其发送数据包的地址 可能导致服务器检测到连接迁移。这个 确保执行支持迁移的机制，即使 没有经历NAT重新绑定或真正迁移的客户端。 变化 地址可以导致对等体重置其拥塞控制状态（请参见 第9.4节），因此地址只能偶尔更改。
9. 耗尽可用连接ID的端点无法探测新路径或 启动迁移，也不能响应其对等体的探测或尝试 迁移。 为了确保迁移是可能的，并且数据包在不同的 路径无法关联，则端点应提供新的连接ID 对等体迁移;参见第5.1.1节。 如果对等体可能已耗尽可用资源， 连接ID，迁移端点可以在中包含NEW_CONNECTION_ID帧 在新的网络路径上发送的所有分组。

### 服务器的首选地址(Server's Preferred Address)

1. QUIC允许服务器接受一个IP地址上的连接并尝试 将这些连接传输到更首选的地址 握手。 当客户端最初连接到 由多个服务器共享的地址，但更愿意使用单播地址 确保连接稳定性。本节介绍迁移的协议 连接到首选服务器地址。
2. 不支持在连接过程中将连接迁移到新的服务器地址 本文件中指定的QUIC版本。如果客户端接收到数据包 从新的服务器地址（如果客户端尚未启动迁移） 地址，客户端应该丢弃这些数据包。

#### 传送首选地址(Communicating a Preferred Address)

1. 服务器通过包含preferred_address来传送首选地址 TLS握手中的传输参数。
2. 服务器可以传送每个地址族的首选地址（IPv4和 IPv6），以允许客户端选择最适合其网络附件的一个。
3. 一旦握手被确认，客户端应该从服务器提供的两个地址中选择一个并启动路径验证（参见8.2节）.客户端使用从preferred_address传输参数或NEW_CONNECTION_ID帧中获取的任何先前未使用的活动连接ID来构造分组。
4. 一旦路径验证成功，客户端就应该开始发送所有 使用新的连接ID将将来的分组发送到新的服务器地址，以及 停止使用旧的服务器地址。 如果路径验证失败，客户端 必须继续发送所有未来的数据包到服务器的原始IP地址。

#### 迁移到首选地址(Migration to a Preferred Address)

1. 迁移到首选地址的客户端必须验证其地址 迁移前选择;参见第21.5.3节。
2. 服务器在接受连接后的任何时候都可能收到发往其首选IP地址的数据包。如果此数据包包含PATH_CHALLENGE帧，则服务器将按照8.2节发送包含PATH_RESPONSE帧的数据包。服务器必须从它的原始地址发送非探测包，直到它在它的首选地址接收到来自客户端的非探测包，直到服务器验证了新的路径。
3. 服务器必须探测从其首选地址到客户端的路径。 这有助于防止攻击者发起虚假迁移。
4. 一旦服务器已经完成其路径验证并且已经在其优选地址上接收到具有新的最大分组号的非探测分组，服务器就开始专门从其优选IP地址向客户端发送非探测分组。服务器应该丢弃在旧IP地址上接收的此连接的较新数据包。服务器可以继续处理在旧IP地址上接收到的延迟数据包。
5. 服务器在preferred_address传输中提供的地址 参数仅对提供它们的连接有效。A类 客户端不得将这些用于其他连接，包括 从当前连接恢复。

#### 客户端迁移与首选地址的交互(Interaction of Client Migration and Preferred Address)

1. 客户端在迁移到之前可能需要执行连接迁移 服务器的首选地址。 在这种情况下，客户端应该执行路径 从客户端的 新地址。
2. 如果服务器首选地址的路径验证成功，则客户端必须 放弃对原始地址的验证并迁移到使用服务器的 首选地址。 如果服务器首选地址的路径验证失败 但验证服务器的原始地址成功，则客户端可以迁移 发送到其新地址并继续发送到服务器的原始地址。
3. 如果在服务器的首选地址接收到的数据包具有不同的源 与握手期间从客户端观察到的地址相比，服务器必须 防范第节中所述的潜在攻击9.3.1 以及9.3.2。 除了有意同时移徙外， 这也可能是因为客户端的接入网络使用了不同的NAT 绑定服务器的首选地址。
4. 服务器应该在接收到来自不同地址的探测包时启动到客户端新地址的路径验证;参见第8节。
5. 迁移到新地址的客户端应该使用 服务器的相同地址族。
6.  preferred_address传输参数中提供的连接ID不是 特定于所提供的地址。此连接ID提供给 确保客户端具有可用于迁移的连接ID，但 客户端可以在任何路径上使用此连接ID。

### IPv6流标签的使用与迁移(Use of IPv6 Flow Label and Migration)

1. 使用IPv6发送数据的端点应在以下位置应用IPv6流标签 符合[RFC6437]，除非本地API不允许设置IPv6 流程标签。
2. 流标签生成必须设计为最小化以下机会 与先前使用的流标签的可链接性，如稳定流标签将 能够关联多条路径上的活动;参见第9.5节。
3. [RFC6437]建议使用伪随机函数导出值以生成流标签。当生成流标签时，除了源地址和目的地地址之外还包括目的地连接ID字段确保了改变与其他可观察标识符中的改变同步。将这些输入与本地秘密相结合的加密散列函数是实现这一点的一种方式。

## 连接终止(Connection Termination)

已建立的QUIC连接可以通过以下三种方式之一终止：
idle timeout (Section 10.1) 空闲超时（第10.1节）
immediate close (Section 10.2) 立即关闭（10.2节）
stateless reset (Section 10.3)无状态重置（10.3节）
一个终点五月如果连接状态上没有经过验证的路径，则放弃该连接状态 其可以发送分组;见第8.2节。

### 空闲超时(Idle Timeout)

1. 如果任一端点在其传输中指定了max_idle_timeout 参数（第18.2节），则连接是静默连接 关闭，并且当它保持空闲的时间超过 由两个端点通告的max_idle_timeout值的最小值。
2. 每个端点都通告max_idle_timeout，但有效值 计算为两个通告值中的最小值（或 如果只有一个端点通告非零值，则为唯一通告值）。签署人 通知max_idle_timeout时，端点提交启动立即 关闭（第10.2节），如果在生效前放弃连接 价值观。
3. 端点在接收到来自其对等体的分组时重新启动其空闲定时器，并且 处理成功。端点在发送 ack-eliciting分组如果自上次以来没有发送其它ack-eliciting分组 接收和处理分组。发送数据包时重新启动此计时器 确保在启动新活动后不关闭连接。
4. 为避免空闲超时时间过短，端点必须增加 空闲超时周期至少为当前探测超时（PTO）的三倍。 这允许多个PTO到期，因此多个探测器将 空闲超时前发送和丢失。

#### 活性测试(Liveness Testing)

1. 在接近有效超时时发送数据包的端点有以下风险 因为空闲超时周期可能已经过期，所以在对等体上丢弃它们 在这些分组到达之前在对等体处。
2. 端点可以发送PING或其他确认引发帧来测试 如果对等体可能很快超时，例如在PTO内，则连接活动性; see Section 6.2 of [QUIC-RECOVERY]. 如果有的话，这是特别有用的 无法安全地重试可用的应用程序数据。请注意，应用程序 确定重试哪些数据是安全的。

#### 延迟空闲超时(Deferring Idle Timeout)

1. 在以下情况下，端点可能需要发送ack-eliciting数据包以避免空闲超时 它期待响应数据，但没有或无法发送应用程序 数据。
2. QUIC的实现可能会为应用程序提供一个选项， 空闲超时。 当应用程序希望避免 已与打开的连接相关联但未 预期交换应用程序数据一段时间。 使用此选项时， 端点可以定期发送PING帧（第19.2节），这将导致 对等体重新开始其空闲超时周期。 发送包含PING的数据包 帧重新启动此端点的空闲超时（如果这是第一个 自接收到分组以来发送的ACK引出分组。 发送PING帧会导致 对等体以确认响应，这也会重新启动空闲 端点的超时。
3. 使用QUIC的应用程序协议应提供有关何时延迟 空闲超时是适当。 不必要地发送PING帧可能会导致 对性能的不利影响。
4. 如果在比使用max_idle_timeout传输参数协商的时间更长的时间内没有发送或接收数据包，则连接将超时;参见第10节。然而，中间盒中的状态可能会比这更早超时。虽然[RFC4787]中的REQ-5建议2分钟的超时间隔，但经验表明，每30秒发送一次数据包对于防止大多数中间盒丢失UDP流[GATEWAY]的状态是必要的。

### 立即关闭(Immediate Close)

1. 端点发送CONNECTION_CLOSE帧（19.19节）到 立即终止连接。 CONNECTION_CLOSE帧导致所有 水流立即关闭;开放流可以假设为 隐式重置。
2. 发送CONNECTION_CLOSE帧后，端点立即进入 关闭状态;参见第10.2.1节。在接收到CONNECTION_CLOSE帧之后， 端点进入引流状态;参见第10.2.2节。
3. 违反方案将导致立即关闭。
4. 在应用程序协议已安排为 关闭连接。 这可能是在应用程序协议协商 正常关机。 应用协议可以交换如下消息 两个应用程序终结点都需要同意连接可以 closed，之后应用程序请求QUIC关闭连接。 当QUIC随后关闭连接时，将使用带有 应用程序提供的错误代码将用于向对等体发信号通知关闭。
5. 存在关闭和排空连接状态以确保连接 干净地关闭并且延迟或重新排序的分组被适当地丢弃。 这些状态应持续至少三倍于当前PTO间隔 定义在[快速恢复]中。
6. 在退出关闭或排空状态之前处理连接状态 可能导致端点生成不必要的无状态重置，当它 接收迟到的分组。 具有一些替代方法的终点 为了确保迟到的分组不会引起响应，例如那些 能够关闭UDP套接字，可以提前结束这些状态以允许 以实现更快的资源恢复。 保留开放套接字以接受 新连接不应该过早结束关闭或排空状态。
7. 一旦它的关闭或排空状态结束，端点应该丢弃所有的连接状态.端点可以发送一个无状态复位以响应任何进一步的属于这个连接的进入数据包。

#### 关闭连接状态(Closing Connection State)

1. 端点在启动立即关闭后进入关闭状态。
2. 在关闭状态下，端点仅保留足够的信息来生成 包含CONNECTION_CLOSE帧的数据包，用于将数据包标识为属于 到连接。处于关闭状态的端点发送包含 CONNECTION_CLOSE帧，用于响应其归属的任何传入数据包 联系。
3. 端点应该限制它在关闭状态下生成数据包的速率。例如，端点可以在响应接收到的分组之前等待数目逐渐增加的接收到的分组或时间量。
4. 端点的选定连接ID和QUIC版本就足够了 用于标识用于关闭连接的分组的信息;端点可以 丢弃所有其它连接状态。不需要正在关闭的端点 以处理任何接收到的帧。端点可以保留数据包保护密钥 传入数据包，以允许其读取和处理CONNECTION_CLOSE帧。
5. 端点可以在进入关闭状态时丢弃数据包保护密钥，并且 发送包含CONNECTION_CLOSE帧的数据包以响应任何UDP 接收到的数据报。但是，放弃数据包保护的端点 密钥不能识别和丢弃无效分组。为了避免被用作 放大攻击，此类端点必须限制数据包的累积大小 它将发送三倍于所接收数据包累积大小的数据包 并归因于该连接。为了最小化端点 保持关闭连接，端点可以发送完全相同的包 响应任何接收到的分组。(**允许重新传输结束数据包是 对每个分组使用新分组号的要求;见 Section 12.3. 发送新的数据包编号主要有利于 丢失恢复和拥塞控制，预计这两个功能不相关 用于闭合连接。重传最后的分组需要更少的状态。**)
6. 当处于关闭状态时，端点可以从新的源接收数据包 address  possibly indicating a connection migration; see Section 9. 安 endpoint in the closing state MUST either discard packets received from an 未验证的地址或限制它发送到的数据包的累积大小 将未验证地址的大小压缩为从该地址接收的数据包大小的三倍 地址。
7. 终结点在关闭时不应处理密钥更新（第六节属于[快速TLS]）.密钥更新可能会阻止端点从 关闭状态更改为正在排出状态，因为端点将无法 处理随后接收到的分组，但是它没有其他影响。

#### 排水连接状态(Draining Connection State)

1. 端点收到CONNECTION_CLOSE后即进入排空状态 帧，它指示其对等方正在关闭或耗尽。否则 与关闭状态相同，处于排出状态的端点不得发送 任何数据包。一旦连接成功，就不需要保留数据包保护密钥 处于排空状态。
2. 接收CONNECTION_CLOSE帧的端点可以发送单个数据包 包含CONNECTION_CLOSE帧，然后使用 NO_ERROR代码（如果适用）。 端点不能再发送数据包。做 因此可能导致CONNECTION_CLOSE帧的持续交换，直到出现以下情况之一 端点退出关闭状态。
3. 端点可以从关闭状态进入正在排出状态，如果它收到 CONNECTION_CLOSE帧，该帧指示对等体也正在关闭或 排水。在这种情况下，当关闭状态将 已经结束了。换句话说，端点使用相同的结束时间，但会停止 在此连接上传输任何数据包。

#### 握手期间立即关闭(Immediate Close during the Handshake)

发送CONNECTION_CLOSE帧时，目标是确保对等体 处理该帧。 通常，这意味着在数据包中发送帧， 最高级别的分组保护以避免分组被丢弃。 之后 确认握手（参见第4.1.2节属于[快速TLS]），一个端点必须 在1-RTT分组中发送任何CONNECTION_CLOSE帧。 但是在此之前 确认握手后，可能会出现更高级的数据包保护 密钥对对等体不可用，因此另一个CONNECTION_CLOSE帧五月是 在使用较低分组保护级别的分组中发送。 更具体地说：
1. 客户端将始终知道服务器是否具有握手密钥（请参见 节17.2.2.1），但是服务器可能不知道 客户端具有握手密钥。 在这些情况下，服务器应该 在握手和初始数据包中发送CONNECTION_CLOSE帧，以确保 它们中的至少一个可由客户端处理。
2. 在0-RTT数据包中发送CONNECTION_CLOSE帧的客户端不能 确保服务器已接受0-RTT。 发送CONNECTION_CLOSE帧 使服务器更有可能接收到 关闭信号，即使可能未收到应用程序错误代码。
3. 在确认握手之前，对等体可能无法处理1-RTT 数据包，因此端点应该在两个握手中发送CONNECTION_CLOSE帧 和1-RTT分组。 服务器还应在 初始数据包。

在初始化或握手数据包中发送0x1d类型的CONNECTION_CLOSE可能会暴露应用程序状态或用于更改应用程序状态。在初始化或握手数据包中发送帧时，必须将0x1d类型的CONNECTION_CLOSE替换为0x1c类型的CONNECTION_CLOSE。否则，可能会泄露有关应用程序状态的信息。端点必须清除原因短语字段的值，并且在转换为0x1c类型的CONNECTION_CLOSE时应该使用APPLICATION_ERROR代码。以多种数据包类型发送的CONNECTION_CLOSE帧可以合并为 single UDP datagram; see Section 12.2. 

端点可以在初始数据包中发送CONNECTION_CLOSE帧。这可能是对在初始或握手数据包中接收到的未经身份验证的信息的响应。这种立即关闭可能会使合法连接暴露于拒绝服务。QUIC不包括握手期间针对路径上攻击的防御措施;参见第21.2节。但是，如果端点丢弃非法数据包而不是使用CONNECTION_CLOSE终止连接，则攻击者可能会更难实施某些形式的拒绝服务，这是以减少合法对等方的错误反馈为代价的。由于这个原因，如果在缺乏认证的数据包中检测到错误，端点可以丢弃数据包而不是立即关闭。

尚未建立状态的端点，如检测到 初始数据包出错，不进入关闭状态。 一种端点，其 没有连接的状态不会进入关闭或排空期 发送CONNECTION_CLOSE帧。

### 无状态重置(Stateless Reset)

1. 对于无权访问连接状态的端点，无状态重置是作为最后手段提供的选项。崩溃或中断可能会导致对等端继续向无法正确继续连接的终结点发送数据。一个端点可以发送一个无状态复位以响应接收到一个它不能与一个活动连接相关联的数据包。
2. 无状态重置不适用于指示活动连接中的错误。希望传递致命连接错误的端点必须使用CONNECTION_CLOSE帧（如果可以）。
3. 为了支持此过程，端点将发出无状态重置令牌，该令牌是 16-字节值，很难猜测。 如果对等体随后接收到 无状态重置，这是一个UDP数据报，结束于无状态 重置令牌，对等项将立即结束连接。
4. 无状态重置令牌特定于连接ID。端点发出 通过在无状态重置令牌字段中包含值来创建无状态重置令牌 新连接ID帧的长度。服务器还可以发出无状态重置令牌 应用于连接ID的握手期间的传输参数 它在握手期间选择。这些交换是受加密保护的， 因此只有客户端和服务器知道它们值。请注意，客户端不能使用 stateless_reset_token传输参数，因为它们传输参数 没有保密保护
5. 当令牌的关联连接ID通过 退出连接ID帧（第19.16节）。
6. 接收到无法处理的数据包的端点将在 以下布局（参见第1.3节）：

Stateless Reset {
  Fixed Bits (2) = 1 
  Unpredictable Bits (38..) 
  Stateless Reset Token (128) 
}

无状态重置
这种设计确保了无状态重置--在可能的范围内-- 与具有短报头的常规分组没有区别。

7. 无状态重置使用整个UDP数据报，从前两位开始 分组报头的长度。 第一个字节的剩余部分和一个任意数 它后面的字节数设置为“应该”无法区分的值 从随机。 数据报的最后16个字节包含一个无状态复位令牌。
8. 对于非预期接收方的实体，无状态重置将显示为 是具有短报头的分组。 要使无状态重置显示为有效 QUIC数据包，不可预测位字段需要包括至少38位 数据（或5字节，减去两个固定位）。
9. 如果接收方需要使用连接ID，则21字节的最小大小不能保证无状态重置难以与其他数据包区分。为了实现这一目的，端点应确保其发送的所有数据包至少比其请求对等体包含在其数据包中的最小连接ID长度长22字节，并在必要时添加填充帧。这确保了对等方发送的任何无状态重置与发送到端点的有效数据包无法区分。发送无状态重置以响应43字节或更短的数据包的端点应该发送比其响应的数据包短一个字节的无状态重置。
10. 这些值假定无状态重置标记的长度与 最小扩展的分组保护AEAD。 其他不可预测的字节 如果端点可能已经协商了分组保护方案 具有较大的最小膨胀。
11. 端点不得发送三倍或更大的无状态重置 比它接收的分组大以避免被用于放大。 第10.3.3节描述了无状态重置大小的其他限制。
12. 终点必须丢弃太小而不是有效QUIC分组的分组。 至 使用中定义的AEAD函数集给予一个示例[快速TLS]，短 小于21字节的报头分组永远是无效的。
13. 端点必须发送格式化为带有短报头的数据包的无状态重置。 但是，端点必须处理以有效的无状态重置令牌结尾的任何数据包 作为无状态复位，因为其他QUIC版本可能允许使用长 标题。
14. 一个端点可以发送一个无状态复位来响应一个带有长报头的数据包.在无状态重置令牌可用于对等项之前，发送无状态重置无效。在这个QUIC版本中，只有在连接建立期间才使用具有长报头的分组。由于无状态重置令牌在连接建立完成或接近完成之前不可用，因此忽略具有长报头的未知数据包可能与发送无状态重置一样有效。
15. 端点无法从带有短 标头;因此，它无法在无状态 重置。 因此，目标连接ID将不同于所使用的值 在之前的数据包中。 随机目标连接ID使连接ID 似乎是移动到使用提供的新连接ID的结果 a NEW_CONNECTION_ID frame; see Section 19.15. 
16. 使用随机连接ID会导致两个问题：

a. 数据包可能无法到达对等方。 如果目标连接ID为 对于路由到对等体至关重要，则此数据包可能会被错误地 路由。 这也可能触发另一无状态重置作为响应;见 第10.3.3节。 未正确路由的无状态重置是 错误检测和恢复机制无效。 在这种情况下，终点 将需要依靠其他方法--如计时器--来检测 连接失败。
b. 随机生成的连接ID可由 对等体将其标识为潜在的无状态重置。 一种端点，其 偶尔使用不同的连接ID可能会引入一些不确定性 关于这个。
17. 这种无状态复位设计专用于QUIC版本1。 一种端点，其 支持多个版本的QUIC需要生成无状态复位，该无状态复位将 被支持端点可能支持的任何版本的对等体接受 (or在丢失状态之前可能已经支持）。 新版本的设计者 QUIC需要意识到这一点，并（1）重新使用该设计或（2）使用 除了最后16个字节之外的用于携带数据的分组部分。


#### 检测无状态重置(Detecting a Stateless Reset)

1. 端点检测到潜在的无状态重置时，使用 UDP数据报。 端点会记住所有关联的无状态重置令牌 具有最近发送的数据报的连接ID和远程地址。 这包括NEW_CONNECTION_ID帧中的无状态重置令牌字段值 和服务器的传输参数，但不包括无状态重置令牌 与未使用或停用的连接ID相关联。 终点 通过比较最后16个数据包，将接收到的数据包标识为无状态重置 字节的数据报，其中所有无状态重置令牌与远程设备相关联 接收数据报的地址。
2. 可以对每个入站数据报执行这种比较。如果来自数据报的任何数据包被成功处理，端点可以跳过这个检查.但是，当输入数据报中的第一个数据包不能与连接相关联或不能被解密时，必须执行比较。
3. 端点不得检查与关联的任何无状态重置令牌 未使用的连接ID或已停用的连接ID。
4. 当比较一个数据报和无状态重置令牌值时，端点必须在不泄漏令牌值信息的情况下执行比较。例如，以恒定时间执行该比较保护了各个无状态复位令牌的值不通过定时侧信道泄漏信息。另一种方法是存储和比较无状态复位令牌的变换值而不是原始令牌值，其中变换被定义为使用密钥的密码安全伪随机函数（例如，块密码、散列消息认证码（HMAC）[RFC2104]）。端点不应保护有关数据包是否成功解密或有效无状态重置令牌数量的信息。
5. 如果数据报的最后16个字节的值与无状态复位相同 令牌，则端点必须进入清空期，并且不再发送任何内容 此连接上的数据包。

#### 计算无状态重置令牌(Calculating a Stateless Reset Token)

1. 无状态重置令牌必须很难猜。 为了创建一个 无状态重置令牌，端点可以随机生成[随机]项目a 为它创建的每个连接保密。 然而，这呈现了 群集或存储中存在多个实例时的协调问题 可能丢失状态的端点的问题。 无状态重置 处理状态丢失的情况，因此这种方法不是最佳的。
2. 单个静态密钥可用于到同一端点的所有连接，方法是 使用伪随机函数生成所述证明，所述伪随机函数取静态密钥，以及 端点选择的连接ID（参见第5.1节）作为输入。 安 端点可以使用HMAC [RFC2104]（例如，HMAC（静态密钥， connection_id））或基于HMAC的密钥导出函数（HKDF）[RFC5869] (for示例，使用静态密钥作为输入密钥材料，连接 ID作为盐）。 此函数的输出被截断为16个字节以生成 该连接的无状态重置令牌。
3. 丢失状态的终结点可以使用相同的方法生成有效的 无状态重置令牌。 连接ID来自 端点接收。
4. 这种设计依赖于对等点始终在其数据包中发送连接ID，以便端点可以使用来自数据包的连接ID来重置连接。使用此设计的端点必须对所有连接使用相同的连接ID长度，或者对连接ID的长度进行编码，以便可以在没有状态的情况下恢复连接ID。此外，它不能提供长度为零的连接ID。
5. 显示无状态重置令牌允许任何实体终止连接，因此一个值只能使用一次。这种选择无状态重置令牌的方法意味着连接ID和静态密钥的组合不能用于另一个连接。如果共享静态密钥的实例使用相同的连接ID，或者攻击者可以将数据包路由到没有状态但具有相同静态密钥的实例，则可能发生拒绝服务攻击;参见第21.11节。通过显示无状态重置令牌而重置的连接的连接ID不得在共享静态密钥的节点处被重新用于新连接。
6. 相同的无状态重置令牌不能用于多个连接ID。 终点不需要将新值与所有先前值进行比较， 但重复值可能被视为类型为 方案违背。注意，无状态复位没有任何加密保护。

#### 成环(Looping)

1. 无状态重置的设计使得在不知道无状态重置的情况下 令牌它与有效分组是不可区分的。 例如，如果服务器 向另一台服务器发送无状态重置，它可能会收到另一个无状态重置 重置，这可能导致无限的交换。
2. 端点必须确保其发送的每个无状态重置小于 触发它的数据包，除非它保持的状态足以防止 循环。 如果出现循环，这将导致数据包最终也 小到可以触发响应。
3. 端点可以记住它已发送的无状态重置的数量 一旦达到限制，则停止生成新的无状态重置。 使用单独的 不同远程地址的限制将确保无状态重置 用于在其他对等点或连接已用尽限制时关闭连接
4. 小于41字节的无状态复位可能被标识为 由观察者重置，具体取决于对等方的 连接ID。 相反，不发送无状态复位以响应 小数据包可能会导致无状态重置在检测中无效 仅发送非常小的分组的断开连接的情况;这样 故障可能仅由诸如定时器之类的其它装置来检测。

## 错误处理(Error Handling)

1. 检测到错误的端点应该将该错误的存在通知给 它的同伴。 传输级错误和应用程序级错误都可能影响 完整连接;参见第11.1节。 仅应用程序级 错误可以被隔离到单个流;参见第11.2节。
2. 最合适的错误代码（第20节）应包含在 发出错误信号的帧。 如果本规范确定了错误 条件，它还标识所使用的错误代码;尽管这些 不同的实施战略如按要求表述，可能会导致 报告不同的错误。 特别是，端点可以使用任何 检测到错误条件时的适用错误代码;一般错误代码 (such作为PROTOCOL_VIOLATION或INTERNAL_ERROR）始终可以用来代替 特定错误代码。
3. 无状态复位（第10.3节）不适用于任何可以用CONNECTION_CLOSE或RESET_STREAM帧发出信号的错误。具有在连接上发送帧所必需的状态的端点不得使用无状态重置。

### 连接错误(Connection Errors)

1. 导致连接不可用的错误，如明显的 违反协议语义或状态损坏，从而影响整个 连接，必须使用CONNECTION_CLOSE帧发出信号 （第19.19节）。
2. 特定于应用程序的协议错误使用CONNECTION_CLOSE发出信号 帧类型为0x1d的帧。 特定于传输的错误， 包括本文档中描述的所有内容，均载于 帧类型为0x1c的连接_关闭帧。
3. CONNECTION_CLOSE帧可能在丢失的数据包中发送。如果端点在终止的连接上接收到更多的数据包，它应该准备重发包含CONNECTION_CLOSE帧的数据包。限制重发的次数和发送该最终分组的时间限制了在终止的连接上花费的努力。
4. 选择不重新传输包含CONNECTION_CLOSE的数据包的端点 帧有对等体丢失第一个这样的分组的风险。 唯一可用的机制 对于继续接收已终止连接的数据的端点 尝试无状态重置过程（第10.3节）。
5. 由于初始数据包的AEAD不提供强身份验证，因此 端点可以丢弃无效的初始数据包。 丢弃初始数据包是 即使本规范另有规定，也允许连接错误。 端点只有在不处理中的帧时才能丢弃数据包 打包或恢复任何处理的效果。 丢弃无效的首字母 数据包可用于减少拒绝服务的风险;见 第21.2节

### 流错误(Stream Errors)

1. 如果应用程序级错误影响单个流，但在其他情况下 连接处于可恢复状态时，端点可以发送RESET_STREAM帧 （第19.4节），以适当的错误代码终止 受影响河流。
2. 在不涉及应用协议的情况下重置流可以 使得应用协议进入不可恢复状态。 复位_流 必须仅由使用QUIC的应用程序协议启动。
3. RESET_STREAM中携带的应用程序错误代码的语义为 由应用协议定义。 只有应用程序协议能够 使得流被终止。 应用程序协议的本地实例 使用直接API调用，远程实例使用STOP_SENDING帧，该帧 触发自动RESET_STREAM。
4. 应用程序协议应该定义处理如下流的规则 被任一端点提前取消。

## 数据包和帧(Packets and Frames)
1. QUIC端点通过交换数据包进行通信。数据包具有机密性 和完整性保护;参见第12.1节。数据包在UDP中传输 数据报;参见第12.2节。
2. 该版本的QUIC在连接建立期间使用长分组报头;参见第17.2节。具有长报头的数据包是初始（第17.2.2节）、0-RTT（第17.2.3节）、握手（第17.2.4节）和重试（第17.2.5节）。版本协商使用具有长报头的独立于版本的分组;参见第17.2.1节。
3. 标头较短的数据包设计为开销最小，并用于 在建立连接并且1-RTT密钥可用之后;见 第17.3节。

### 受保护的数据包(Protected Packets)

1. QUIC数据包具有不同级别的加密保护，具体取决于 数据包类型。数据包保护的详细信息可在[QUIC-TLS]中找到;这 一节概述了所提供的保护。
2. 版本协商数据包没有密码保护;见 [快速不变量]。
3. 重试数据包使用AEAD函数[AEAD]来防止 意外修改。
4. 初始数据包使用AEAD函数，其密钥使用 在导线上可见的值。因此，初始数据包没有 有效的保密保护。存在初始保护以确保 数据包的发送方位于网络路径上。任何接收 来自客户端的初始数据包可以恢复密钥，从而使它们能够 读取数据包的内容，并生成初始数据包 在任一端点成功通过身份验证。 AEAD还保护初始 防止意外修改的数据包。
5. 所有其他数据包都使用从加密 握手。 加密握手确保只有正在通信的 端点接收握手、0-RTT和1-RTT的相应密钥 数据包。 使用0-RTT和1-RTT密钥保护的数据包具有强 机密性和完整性保护。
6. 出现在某些分组类型中的分组号字段具有作为报头保护的一部分应用的可选机密性保护;有关详细信息，请参见[QUIC-TLS]的第5.4节。基础分组号随着在给定分组号空间中发送的每个分组而增加;详见第12.3节。

### 合并数据包(Coalescing Packets)

1. 初始（第17.2.2节）、0-RTT（第17.2.3节）和握手（第17.2.4节）数据包包含确定数据包结束的长度字段。长度包括分组号和有效载荷字段，这两个字段都是保密的并且初始长度未知。有效载荷字段的长度在去除报头保护后获知。
2. 使用长度字段，发送方可以将多个QUIC分组合并成一个UDP数据报。这可以减少完成加密握手和开始发送数据所需的UDP数据报的数量。这也可以用于构造路径最大传输单元（PMTU）探测;参见第14.4.1节。接收器必须能够处理合并的数据包。
3. 按照加密级别递增的顺序来合并分组（初始、0-RTT、握手、1-RTT;参见[QUIC-TLS]的第4.1.4节）使得接收器更有可能将能够在单次通过中处理所有分组。具有短报头的数据包不包含长度，因此它只能是UDP数据报中包含的最后一个数据包。如果要以相同的加密级别发送多个帧，则端点应该在单个数据包中包含多个帧，而不是以相同的加密级别合并多个数据包。
4. 接收方可以根据包含在 UDP数据报。 发送方不得合并具有不同连接的QUIC数据包 ID到单个UDP数据报中。 接收器应忽略任何后续数据包 中的第一个数据包具有不同的目标连接ID 数据报。
5. 每个QUIC数据包合并成一个单一的UDP数据报是独立和完整的。合并QUIC数据包的接收方必须单独处理每个QUIC数据包，并单独确认它们，就好像它们是作为不同UDP数据报的有效载荷接收的一样。例如，如果解密失败（因为密钥不可用或任何其他原因），接收方可以丢弃或缓冲该分组以供以后处理，并且必须尝试处理剩余的分组。
6. 重试数据包（17.2.5节）、版本协商数据包（17.2.1节）和具有短报头的数据包（17.3节）不包含长度字段，因此不能跟随同一UDP数据报中的其他数据包。还要注意，不存在重试或版本协商数据包与另一个数据包合并的情况。

### 数据包编号(Packet Numbers)

1. 数据包编号是0到262-1范围内的整数。此数字用于确定用于分组保护的加密现时。每个端点都维护一个单独的数据包编号，用于发送和接收。
2. 数据包编号限制在此范围内，因为它们需要可表示 整个在ACK帧的最大确认字段中（第19.3节）。 然而，当存在于长或短报头中时，分组数目被减少，并且 以1到4字节编码;参见第17.1节。
3. 版本协商（第17.2.1节）和重试（第17.2.5节）数据包 不包括分组号。
4. QUIC中的数据包编号分为三个空格：
Initial space: 初始空间  .所有初始数据包（第17.2.2节）均在此空间中。
Handshake space: 握手空间： 所有握手数据包（第17.2.4节）都在此空间中。
Application data space: 应用程序数据空间： 所有0-RTT（第17.2.3节）和1-RTT（第17.3.1节）数据包都在此空间中。

5. 概念上，分组编号空间是分组可以被 处理并确认。 初始数据包只能使用Initial发送 数据包保护密钥，并在也是初始值的数据包中确认 数据包。 类似地，握手数据包在握手加密时发送 并且只能在握手数据包中确认。
6. 这将强制在不同的 分组号空间。 每个空间中的数据包编号从数据包编号0开始。 在同一数据包编号空间中发送的后续数据包必须增加数据包 用至少一个数字表示。
7. 0-RTT和1-RTT数据存在于同一个包号空间，进行丢失恢复 算法更容易在两种分组类型之间实现。
8. 0-RTT和1-RTT数据存在于同一个包号空间，进行丢失恢复 算法更容易在两种分组类型之间实现。
9. 一种接收器，必须丢弃新的未受保护的分组，除非确定它 尚未处理同一个中具有相同数据包编号的另一个数据包 分组号空间。重复抑制必须删除数据包后发生 保护，原因见第9.5节属于[快速TLS]。
10. 为了检测重复数据而跟踪所有单个数据包的端点存在累积过多状态的风险。检测副本所需的数据可以通过维持最小分组数来限制，低于该最小分组数的所有分组都被立即丢弃。任何最小值都需要考虑往返时间的大变化，这包括对等体可能以大得多的往返时间探测网络路径的可能性;参见第9节。
11. 中描述了在发送器处的分组号编码和在接收器处的解码 Section 17.1. 

### 框架和框架类型(Frames and Frame Types)

1. 去除数据包保护后，QUIC数据包的有效负载由 完整帧的序列，如所示图十一。 版本 协商、无状态重置和重试数据包不包含帧。
Packet Payload {
  Frame (8..) ... 
}
包含帧的数据包的有效载荷必须包含至少一个帧，并且可以包含多个帧和多个帧类型。一个端点必须将接收到的不包含帧的数据包视为PROTOCOL_VIOLATION类型的连接错误。帧始终适合单个QUIC数据包，不能跨越多个数据包。

每个帧都以帧类型开始，指示其类型，后跟 附加的类型相关字段：
Frame {
  Frame Type (i) 
  Type-Dependent Fields (..) 
}

表3列出并总结了有关本规范中定义的每种帧类型的信息。该总结的描述见表后。

Type Value 类型值 		Frame Type Name 帧类型名称 			Definition 定义 			Pkts 包装 	Spec 质量标准
0x00 					PADDING 衬垫 						Section 19.1 第19.1节 	IH01 		NP
0x01 					PING 平 								Section 19.2 第19.2节 	IH01 	
0x02-0x03 0x02至0x03 	ACK 确认 							Section 19.3 第19.3节 	IH_1 		NC 不合格
0x04 					RESET_STREAM 复位_流 					Section 19.4 第19.4节 	__01 	
0x05 					STOP_SENDING 停止发送 				Section 19.5 第19.5节 	__01 	
0x06 					CRYPTO 密码 							Section 19.6 第19.6节 	IH_1 	
0x07 					NEW_TOKEN 新令牌 						Section 19.7 第19.7节 	___1 	
0x08-0x0f 				STREAM 溪流 							Section 19.8 第19.8节 	__01 		F 
0x10 					MAX_DATA 最大数据 					Section 19.9 第19.9节 	__01 	
0x11 					MAX_STREAM_DATA 最大流数据 			Section 19.10 第19.10节 	__01 	
0x12-0x13 				MAX_STREAMS 最大_流 					Section 19.11 第19.11节 	__01 	
0x14 					DATA_BLOCKED 数据阻塞 				Section 19.12 第19.12节 	__01 	
0x15 					STREAM_DATA_BLOCKED 流数据阻塞 		Section 19.13 第19.13节 	__01 	
0x16-0x17 				STREAMS_BLOCKED 流_阻塞 				Section 19.14 第19.14节 	__01 	
0x18 0x18位 				NEW_CONNECTION_ID 新连接ID 			Section 19.15 第19.15节 	__01 		P 
0x19 					RETIRE_CONNECTION_ID 退出连接ID 		Section 19.16 第19.16节 	__01 	
0x1a 					PATH_CHALLENGE 路径_挑战 				Section 19.17 第19.17节 	__01 		P 
0x1b 					PATH_RESPONSE 路径_响应 				Section 19.18 第19.18节 	___1 		P 
0x1c-0x1d 				CONNECTION_CLOSE 连接_关闭 			Section 19.19 第19.19节 	ih01 		N 
0x1e 					HANDSHAKE_DONE 握手_完成 				Section 19.20 第19.20节 	___1 	


以上详细说明了每种帧类型的格式和语义 Section 19. 本节的其余部分提供了以下内容的摘要 重要和一般信息。
ACK、STREAM、MAX_STREAMS、STREAMS_BLOCKED和 CONNECTION_CLOSE帧用于携带其他帧特定标志。为所有人 其它帧，帧类型字段简单地标识帧。


列表三列出了每个帧中包含的数据包类型 类型可以出现在中，由以下字符表示：
I:  Initial (Section 17.2.2) 
H:  Handshake (Section 17.2.4)
0: 0-RTT (Section 17.2.3)
1:  1-RTT (Section 17.3.1)
ih:  只有0x1c类型的CONNECTION_CLOSE帧才能出现在初始化或握手中 数据包。

有关这些限制的更多详细信息，请参见第12.5节。注意，所有帧都可以出现在1-RTT分组中。端点必须将接收到的不允许的数据包类型的帧视为PROTOCOL_VIOLATION类型的连接错误。
"规格"列表三汇总了管理的任何特殊规则 帧类型的处理或生成，如下所示 字符数：
N: 仅包含具有此标记的帧的分组不引发ACK;见 Section 13.2. 
C: 仅包含带有此标记的帧的数据包不计入字节数 在飞行中用于拥塞控制目的;参见[快速恢复]。
P: 仅包含具有此标记的帧的数据包可用于探测新的 连接迁移期间的网络路径;参见第9.1节。
F: 具有此标记的帧的内容是受流控制的;见 Section 4. 
"Pkts"和"Spec"列表三不构成IANA的一部分 注册表;请参阅第22.4节。

端点必须将接收到的未知类型的帧视为连接 帧编码错误类型的错误。
在此版本的QUIC中，所有帧都是幂等的。 也就是说，有效帧 当接收多于一次时不会引起不期望的副作用或错误。

帧类型字段使用可变长度整数编码（见第16节），但有一个例外。为了确保简单有效地实现帧解析，帧类型必须使用尽可能短的编码。对于本文档中定义的帧类型，这意味着单字节编码，即使可以将这些值编码为2字节、4字节或8字节的可变长度整数。例如，虽然0x4001是值为1的可变长度整数的合法双字节编码，但PING帧始终被编码为值为0x01的单字节。此规则适用于所有当前和未来的QUIC框架类型。端点可以将使用比所需长度更长的编码的帧类型的接收视为PROTOCOL_VIOLATION类型的连接错误。

### 框架与数空间(Frames and Number Spaces)
1. 某些帧在不同的数据包编号空间中被禁止。这里的规矩 在与建立 连接通常可以出现在任何分组编号空间中的分组中，而 与传输数据关联的那些只能出现在应用程序中 数据包编号空间：
PADDING、PING和CRYPTO帧可以出现在任何数据包编号空间中。
CONNECTION_CLOSE帧在QUIC层（类型0x1c）的信令错误可能出现在任何数据包编号空间中。CONNECTION_CLOSE帧通知应用程序错误（类型0x1d）必须仅出现在应用程序数据包编号空间中。
ACK帧可以出现在任何分组编号空间中，但只能确认出现在该分组编号空间中的分组。然而，如下所述，0-RTT分组不能包含ACK帧。
所有其他帧类型必须仅在应用数据包编号空间中发送。
2. 注意，由于各种原因，不可能在0-RTT分组中发送以下帧：ACK、CRYPTO、Handshake_DONE、NEW_TOKEN、PATH_RESPONSE和RETIRE_CONNECTION_ID。服务器可以将在0-RTT分组中接收到这些帧视为类型为PROTOCOL_VIOLATION的连接错误。

## 分组化和可靠性(Packetization and Reliability)

1. 发送方在QUIC分组中发送一个或多个帧;参见第12.4节。
2. 发送器可以通过在每个QUIC分组中包括尽可能多的帧来最小化每个分组的带宽和计算成本。发送者在发送一个没有被最大打包的包之前，可能会等待一小段时间来收集多个帧，以避免发送大量的小包。一个实现可以使用关于应用程序发送行为的知识或试探法来确定是否等待以及等待多长时间。这个等待时间是一个实现决策，实现应该谨慎地延迟，因为任何延迟都可能增加应用程序可见的延迟。
3. 流多路复用是通过交织来自多个流成一个或多个QUIC分组。 单个QUIC数据包可包括 来自一个或多个流的多个流帧。
4. QUIC的优势之一是避免了跨 多个流。 发生数据包丢失时，只有其中包含数据的流 分组被阻塞，等待接收重传，而其它分组 流可以继续前进。 请注意，当来自多个流的数据 包含在单个QUIC数据包中，则该数据包的丢失会阻塞所有这些 阻碍进步 建议实现尽量少包含 在不损失传输效率的情况下在输出分组中按需传输流 涉及填充不足的分组。

###  数据包处理(Packet Processing)

1. 在数据包保护被成功移除并且数据包中包含的所有帧都被处理之前，数据包不能被确认。对于STREAM帧，这意味着数据已经排队，准备由应用程序协议接收，但它不要求传递和使用数据。
2. 数据包完全处理后，接收方通过以下方式确认收到 发送一个或多个ACK帧，所述ACK帧包含所接收的分组的分组号 数据包。
3. 如果端点能够检测到这种情况，则它应该将接收到它没有发送的数据包的确认视为PROTOCOL_VIOLATION类型的连接错误。关于如何实现这一点的进一步讨论，见21.4节。

### 生成确认(Generating Acknowledgments)

1. 端点确认它们接收和处理的所有数据包。然而，只有 引发确认的数据包会导致在最大确认时间内发送ACK帧 延迟。 未引发确认的数据包仅在收到ACK时才得到确认 帧是出于其他原因发送的。
2. 当出于任何原因发送数据包时，端点应尝试包含 ACK帧（如果最近未发送）。这样做有助于及时丢失 在对等体处的检测。
3. 通常，来自接收机的频繁反馈改善了丢失和拥塞 响应，但这必须与由 发送ACK帧以响应每个ACK引发数据包的接收器。 该 下文提供的指导意见力求实现这一平衡。

#### 发送ACK帧(Sending ACK Frames)

1. 每个数据包应至少被确认一次，并且在使用max_ack_delay传输参数通信的端点的最大延迟内，确认引发数据包必须至少被确认一次;参见第18.2节。max_ack_delay声明一个显式约定：端点承诺决不故意将ACK引出分组的确认延迟超过所指示的值。如果是这样，则任何超出都会累积到RTT估计，并且可能导致来自对等体的伪重传或延迟重传。发送方使用接收方的max_ack_delay值来确定基于定时器的重传超时，详见[QUIC-RECOVERY]第6.2节。
2. 端点必须确认所有引发确认的初始和握手数据包 并且其通告内的所有引发确认的0-RTT和1-RTT数据包 max_ack_delay，但以下情况除外。在握手确认之前， 端点可能没有用于解密握手0-RTT的分组保护密钥， 或者当接收到1-RTT分组时接收1-RTT分组。因此它可能会缓冲它们 当必需的密钥可用时确认它们。
3. 端点必须确认所有引发确认的初始和握手数据包 并且其通告内的所有引发确认的0-RTT和1-RTT数据包 max_ack_delay，但以下情况除外。在握手确认之前， 端点可能没有用于解密握手0-RTT的分组保护密钥， 或者当接收到1-RTT分组时接收1-RTT分组。因此它可能会缓冲它们 当必需的密钥可用时确认它们。
4. 由于只包含ACK帧的数据包不受拥塞控制，因此 端点不得发送多个此类数据包以响应接收 ACK引发分组。
5. 仅发送ACK帧的端点将不会从其对等方接收到确认，除非那些确认被包括在具有ACK引发帧的分组中。当有新的ack-eliciting数据包需要确认时，端点应该发送一个ACK帧和其他帧。当只有非ack-eliciting数据包需要被确认时，端点可以选择在收到ack-eliciting数据包之前不发送ACK帧和输出帧。
6. 仅发送非确认请求数据包的端点可以选择 偶尔将ACK引出帧添加到那些分组以确保它 接收确认;参见第13.2.4节。 在这种情况下，端点 不得在所有数据包中发送确认引发帧，否则 非ACK引出以避免确认的无限反馈循环。
7. 为了帮助在发送端进行丢失检测，端点应该生成 并在接收到ACK引发分组时无延迟地发送ACK帧 或者：
当接收到的分组具有小于另一ACK引出的分组号时 已接收的数据包，或
当分组具有大于最高编号的分组编号时 已接收的ACK引发数据包，并且存在丢失的数据包 在那个数据包和这个数据包之间
8. 同样，中标记有ECN拥塞经历（CE）代码点的数据包 IP报头应该立即得到确认，以减少对等体的响应 到拥塞事件的时间。
9. 中的算法[快速恢复]预期对接收器是弹性的 不遵循上述指南的情况。然而，一种实现 应在仔细考虑以下各项后才能偏离这些要求 更改的性能影响，针对端点所做的连接，以及 用于网络的其他用户。

#### 确认频率(Acknowledgment Frequency)

1. 接收方确定发送确认的频率以响应 引发确认的分组。这种确定涉及权衡。
2. 终点依靠及时确认来检测丢失;见第六节属于[快速恢复]。基于窗口的拥塞控制器，例如所描述的拥塞控制器 在第七节属于[快速恢复]，依靠确认来管理其 拥塞窗口。在这两种情况下，延迟确认都会对 性能。
3. 另一方面，减少只携带 确认降低了数据包传输和处理成本 终点。它可以提高严重不对称链路上的连接吞吐量 并且使用返回路径容量来减少确认业务量; see Section 3 of [RFC3449]. 
4. 接收方应该在接收到至少两个ACK引发分组之后发送ACK帧。此建议在本质上是通用的，并且与TCP端点行为的建议[RFC5681]一致。网络条件的知识、对等体的拥塞控制器的知识、或进一步的研究和实验可以建议具有更好性能特性的替代确认策略。
5. 接收器可以在确定是否 发送ACK帧作为响应。

#### 管理ACK范围(Managing ACK Ranges)

1. 当发送ACK帧时，确认分组的一个或多个范围被 包括在内。 包括较旧数据包的确认可降低 丢失先前发送的ACK帧导致的虚假重新传输，在 较大ACK帧的成本。
2. ACK帧应该总是确认最近接收的数据包，并且 数据包越乱，发送更新的 ACK帧，以防止对等体声明数据包丢失，以及 虚假地重传其包含的帧。 需要ACK帧 以适合单个QUIC分组。 如果不是，则使用较旧的范围 （具有最小分组号的那些）被省略。
3. 接收机限制其记忆的ACK范围的数目（19.3.1节）并在ACK帧中发送，以限制ACK帧的大小并避免资源耗尽。在接收到ACK帧的确认后，接收器应该停止跟踪那些确认的ACK范围.发送方可以期待大多数数据包的确认，但QUIC不保证接收方处理的每个数据包都收到确认。
4. 保留许多ACK范围可能会导致ACK帧变得太大。接收方可以丢弃未确认的ACK范围以限制ACK帧大小，代价是增加来自发送方的重传。如果ACK帧太大而无法装入数据包，则需要这样做。接收方也可以进一步限制ACK帧的大小，以便为其他帧保留空间或限制确认所消耗的容量。
5. 接收机必须保留ACK范围，除非它能确保不会 随后接受编号在该范围内的分组。维持最低限度 数据包数量随着范围的丢弃而增加是实现这一点的一种方法 具有最小的状态。
6. 接收机必须保留ACK范围，除非它能确保不会 随后接受编号在该范围内的分组。维持最低限度 数据包数量随着范围的丢弃而增加是实现这一点的一种方法 具有最小的状态。
7. 接收机应包括包含最大接收数据包的ACK范围 每个ACK帧中的编号。ECN中使用最大确认字段 在发送方进行验证，并且包括比包含在 前一个ACK帧可能导致ECN被不必要地禁用;见 第13.4.2节。
8. 章节13.2.4描述了用于确定哪些分组 以在每个ACK帧中进行确认。 尽管这个算法的目标是 为处理的每个数据包生成确认时，它仍然 可能丢失确认

#### 通过跟踪ACK帧限制范围(Limiting Ranges by Tracking ACK Frames)

1. 发送包含ACK帧的数据包时，中的“最大确认”字段 可以保存该帧。 当包含ACK帧的分组被确认时， 接收方可以停止确认小于或等于最大值的数据包 已发送ACK帧中的已确认字段。
2. 仅发送诸如ACK帧的非ACK引出分组的接收机可以 在很长一段时间内没有接收到确认。 这可能导致 接收器在长时间内保持大量ACK帧的状态 时间，并且它发送的ACK帧可能不必要地大。 在这种情况下， 接收器可以偶尔发送PING或其它小的ACK引出帧， 例如每往返一次，以从对等体引出ACK。
3. 在没有ACK帧丢失的情况下，此算法允许最少1 RTT 重新排序。在ACK帧丢失和重新排序的情况下，此方法不 保证发送方在每个确认不再被发送之前都能看到它 包括在ACK帧中。数据包接收顺序可能混乱，并且所有 包含它们的后续ACK帧可能丢失。在这种情况下，损失 恢复算法可能会导致虚假的重新传输，但发送方会 继续向前迈进。

#### 测量和报告主机延迟(Measuring and Reporting Host Delay)

1. 端点测量在接收到具有最大数据包编号的数据包的时间和发送确认的时间之间有意引入的延迟。端点在ACK帧的ACK延迟字段中编码该确认延迟;参见第19.3节。这允许ACK帧的接收机针对任何有意的延迟进行调整，这对于在确认被延迟时获得路径RTT的更好估计是重要的。
2. 数据包在处理之前可能会保存在OS内核或主机上的其他位置。当填充ACK帧中的ACK延迟字段时，端点不得包含它不控制的延迟。然而，端点应该包括由解密密钥不可用引起的缓冲延迟，因为这些延迟可能很大，并且可能是不重复的。
3. 当测得的确认延迟大于其max_ack_delay时，端点应该报告测得的延迟。当延迟可能很大时，该信息在握手期间特别有用;参见第13.2.1节。

#### ACK帧和数据包保护(ACK Frames and Packet Protection)

1. ACK帧必须仅在与被确认的分组具有相同分组编号空间的分组中携带;参见第12.1节。例如，用1-RTT密钥保护的分组必须在也用1-RTT密钥保护的分组中被确认。
2. 客户端使用0-RTT数据包保护发送的数据包必须由确认 在由1-RTT密钥保护的分组中向服务器发送。 这可能意味着客户端 无法使用这些确认如果服务器加密握手 消息被延迟或丢失。 请注意，相同的限制也适用于其他 服务器发送的数据受1-RTT密钥保护。

#### 填充帧消耗拥塞窗口(PADDING Frames Consume Congestion Window)

1. 包含PADDING帧的数据包被视为传输中的拥塞数据包 控制目的[快速恢复]。仅包含PADDING帧的数据包 因此消耗拥塞窗口但不生成 将打开拥塞窗口。为了避免死锁，发送方应该确保 除了PADDING帧之外还周期性地发送其它帧以引出 来自接收机的确认。

### 信息的重新传输(Retransmission of Information)

1. 被确定为丢失的QUIC分组不被整个重传。该 这同样适用于包含在丢失分组内的帧。相反， 可以在帧中携带的信息在新帧中再次发送 需要。
2. 新的帧和分组用于携带被确定为具有 已经失去了。 通常，当包含信息的数据包 信息被确定为丢失，并且当分组 包含该信息的消息被确认。

 在CRYPTO帧中发送的数据根据中的规则重新传输 [QUIC-RECOVERY]，直到确认所有数据。 CRYPTO中的数据 初始化和握手数据包的帧被丢弃，当 丢弃相应的分组号空间。
 在STREAM帧中发送的应用程序数据将在新的STREAM帧中重新传输 除非端点已经为该流发送了RESET_STREAM。 一旦端点 发送RESET_STREAM帧，则不需要其他STREAM帧。
 ACK帧携带最近的一组确认， 最大确认数据包的确认延迟，如所述 Section 13.2.1.延迟包含以下内容的数据包的传输 ACK帧或重新发送旧的ACK帧可能导致对等方生成 膨胀RTT样本或不必要地禁用ECN。
 RESET_STREAM帧中携带的流传输取消 发送直到确认或直到所有流数据被对等体确认 (that是，在上达到“重置接收”或“数据接收”状态 发送流的一部分）。RESET_STREAM帧的内容不得 在再次发送时改变。
 类似地，取消流传输的请求（如编码在 发送STOP_SENDING帧，直到流的接收部分进入 “数据接收”或“复位接收”状态;见 第3.5节。
 连接关闭信号，包括包含CONNECTION_CLOSE的数据包 当检测到分组丢失时，不再次发送帧。重新发送这些 信号在中进行了描述第十节。
 当前连接最大数据在MAX_DATA帧中发送。一份更新的 如果数据包包含最近的 发送的MAX_DATA帧被声明为丢失或当端点决定更新时 极限。 必须小心避免过于频繁地发送此帧，因为 限制可能会频繁增加，并导致不必要的大量 MAX_DATA frames to be sent; see Section 4.2.
 当前最大流数据偏移在MAX_STREAM_DATA帧中发送。 与MAX_DATA类似，当包含最多 流的最新MAX_STREAM_DATA帧丢失，或当限制为 更新，注意防止帧被过于频繁地发送。安 端点应停止发送MAX_STREAM_DATA帧，当 流进入“大小已知”或“复位接收”状态。
 给定类型的流限制在MAX_STREAMS帧中发送。 喜欢 MAX_DATA，当数据包包含最近的 流类型帧的MAX_STREAMS被声明为丢失，或者当限制为 更新，注意防止帧被过于频繁地发送。
 阻塞信号在DATA_BLOCKED、STREAM_DATA_BLOCKED和 流阻塞帧。DATA_BLOCKED帧具有连接作用域， STREAM_DATA_BLOCKED帧具有流作用域，而STREAMS_BLOCKED帧为 作用域为特定的流类型。如果数据包包含 作用域的最新帧丢失，但仅当端点 在相应的限制上被阻止。这些帧始终包含以下限制 在它们被传输时造成阻塞。
 使用PATH_CHALLENGE帧发送活动或路径验证检查 直到接收到匹配的PATH_RESPONSE帧或直到 不再需要存活性或路径有效性检查。路径_挑战 帧在每次被发送时包括不同的有效载荷。
 使用PATH_RESPONSE帧的路径验证响应只发送一次。 对等体应根据需要发送更多的PATH_CHALLENGE帧以调用 额外的PATH_RESPONSE帧。
 新连接ID在NEW_CONNECTION_ID帧中发送，并在以下情况下重新传输 则包含它们的分组丢失。 此帧的重传携带 相同的序列号值。 同样，也会发送失效的连接ID RETIRE_CONNECTION_ID帧，如果包含它们的数据包 迷失。
 如果包含NEW_TOKEN帧的数据包丢失，则会重新传输这些帧。 没有 特别支持检测重新排序和重复的NEW_TOKEN 帧而不是帧内容的直接比较。
 PING和PADDING帧不包含任何信息，因此丢失PING或PADDING帧 不需要修理。
 握手完成帧必须直到它被确认为止。

3. 端点应该优先重传数据而不是发送新数据，除非 申请中规定的优先级另有说明;见 第2.3节。
4. 即使鼓励发送方组装包含最新 每次发送信息包时，不禁止重新传输 丢失数据包的帧副本。 重传帧副本的发送方 需要处理由于数据包的变化而导致的可用有效负载大小的减少 编号长度、连接ID长度和路径MTU。 接收者必须接受 包含过时帧的数据包，如携带 比在较旧分组中找到的最大数据值小的最大数据值。
5. 一旦数据包被确认，发送方应该避免重传数据包中的信息。这包括在声明丢失后被确认的数据包，这在网络重新排序时可能发生。这样做要求发送方在数据包被声明丢失后保留有关数据包的信息。发送方可以在经过一段足以重新排序的时间后丢弃此信息，例如PTO（[QUIC-RECOVERY]的第6.2节），或基于其他事件（例如达到内存限制）。
6. 一旦数据包被确认，发送方应该避免重传数据包中的信息。这包括在声明丢失后被确认的数据包，这在网络重新排序时可能发生。这样做要求发送方在数据包被声明丢失后保留有关数据包的信息。发送方可以在经过一段足以重新排序的时间后丢弃此信息，例如PTO（[QUIC-RECOVERY]的第6.2节），或基于其他事件（例如达到内存限制）。

### 显式拥塞通知(Explicit Congestion Notification)

1. QUIC端点可使用ECN [RFC 3168]检测和响应网络拥塞。ECN允许端点在IP分组的ECN字段中设置支持ECN的传输（ECT）码点。网络节点随后可通过在ECN字段中设置ECN-CE码点而不是丢弃分组来指示拥塞[RFC 8087]。端点通过降低其发送速率来响应报告的拥塞，如[QUIC-RECOVERY]中所述。
2. 要启用ECN，发送QUIC端点首先确定路径是否支持 ECN标记，对端是否在接收到的IP头中上报ECN值; 参见第13.4.2节。

#### 报告ECN计数(Reporting ECN Counts)

1. ECN的使用要求接收端点从IP读取ECN字段 数据包，这在所有平台上都是不可能的。如果端点不 实现ECN支持或无法访问接收到的ECN字段，则可以 不报告其接收的分组的ECN计数。
2. 即使端点没有在它发送的数据包中设置ECT字段，该端点 必须提供关于其收到的ECN标记的反馈（如果这些标记可访问）。 未能报告ECN计数将导致发送者禁用ECN 用于此连接。
3. 即使端点没有在它发送的数据包中设置ECT字段，该端点 必须提供关于其收到的ECN标记的反馈（如果这些标记可访问）。 未能报告ECN计数将导致发送者禁用ECN 用于此连接。
4. 接收到带有ECT（0）、ECT（1）或ECN-CE码点的IP数据包时， 启用ECN的端点访问ECN字段并增加相应的 ECT（0）、ECT（1）或ECN-CE计数。这些ECN计数包含在后续ACK中 框架;请参见截面13.2以及19.3。
5. 每个数据包编号空间维护单独的确认状态和单独的 ECN计数。 合并的QUIC数据包（参见第12.2节）共享相同的IP 因此ECN计数对于每个合并的QUIC数据包递增一次。
6. ECN计数仅在处理来自接收到的IP数据包的QUIC数据包时递增。这样，重复的QUIC分组不被处理并且不增加ECN计数;有关安全问题，请参见第21.10节。

#### ECN确认(ECN Validation)

1. 有故障的网络设备可能会损坏或错误地断开 携带非零ECN码点的分组。要确保中的连接 如果存在此类设备，端点将验证每个网络的ECN计数 路径，并在检测到错误时禁止在该路径上使用ECN。
2. 要对新路径执行ECN验证：
	端点在早期传出的IP报头中设置ECT（0）码点 在新路径上发送到对等体的数据包[RFC8311]。
	端点监视是否所有使用ECT代码点发送的数据包 最终被视为灭失（第六节属于[快速恢复]），表示 ECN验证失败。
3. 如果端点有理由预期具有ECT代码点的IP数据包可能 被故障网络元件丢弃时，端点可以设置ECT码点 仅针对路径上的前10个输出信息包，或针对3个周期 PTO（请参见第6.2节属于[快速恢复]）.如果所有标记为非零的数据包 ECN代码点随后丢失，则它可以禁用基于以下假设的标记 标记导致了损失。
4. 端点因此尝试使用ECN并为每个新连接验证ECN， 切换到服务器的首选地址时，以及处于活动连接状态时 迁移到新路径。附录A.4描述了一种可能的算法。
5. 探测用于ECN支持的路径的其它方法也是可能的，因为它们是不同的 标记策略。实现可以使用RFC中定义的其他方法;见 [参考文献RFC 8311]。使用ECT（1）代码点的实现需要 使用报告的ECT（1）计数执行ECN确认。

#### 接收包含ECN计数的ACK帧(Receiving ACK Frames with ECN Counts)

1. 网络错误应用ECN-CE标记可能导致降级 连接性能。 接收到包含ECN计数的ACK帧的端点 因此在使用它们之前验证计数。它通过以下方式执行此验证 将新接收到的计数与上次成功接收到的计数进行比较 处理ACK帧。ECN计数的任何增加均根据以下内容进行验证 应用于ACK中新确认的数据包的ECN标记 框架。
2. 如果ACK帧新确认了端点发送的数据包 ECT（0）或ECT（1）码点集，如果对应的 ACK帧中不存在ECN计数。此检查检测网络 将ECN字段置零的元素或不报告ECN标记的对等体。
3. 如果ECT（0）和ECN-CE计数的增加总和，则ECN确认也失败 小于最初发送的新确认数据包的数量 带有ECT（0）标记。 类似地，如果以下各项之和 增加至ECT（1）且ECN-CE计数小于新的数量 发送带有ECT（1）标记的已确认数据包。 这些检查可以检测 由网络重新标记ECN-CE标志。
4. 如果ECT（0）和ECN-CE计数的增加总和，则ECN确认也失败 小于最初发送的新确认数据包的数量 带有ECT（0）标记。 类似地，如果以下各项之和 增加至ECT（1）且ECN-CE计数小于新的数量 发送带有ECT（1）标记的已确认数据包。 这些检查可以检测 由网络重新标记ECN-CE标志。
5. 从重新排序的ACK帧中验证ECN计数可能会导致失败。安 端点不得因处理ACK帧而导致ECN验证失败 这不会增加最大确认分组数。
6. 如果收到的ECT（0）或ECT（1）总计数可能失败，则ECN确认可能失败 超过与每个对应ECT码点一起发送的包的总数。 特别是，当端点接收到非零ECN时，验证将失败 对应于它从未应用的ECT码点的计数。 这张支票 检测数据包在网络中何时被标记为ECT（0）或ECT（1）。

#### ECN确认结果(ECN Validation Outcomes)

1. 如果验证失败，则端点必须禁用ECN。它将停止设置 假设网络路径中存在ECT码点， 或者对等体不支持ECN。
2. 即使验证失败，端点也可以在以下位置重新验证同一路径的ECN 连接中的任何稍后时间。端点可以继续定期 尝试验证。
3. 验证成功后，端点可以继续在 它发送的后续分组，期望该路径具有ECN能力。 网络路由和路径元素可以改变中间连接;端点必须 如果以后验证失败，则禁用ECN。

## 数据报大小(Datagram Size)

1. UDP数据报可以包括一个或多个QUIC分组。数据报大小是指 携带QUIC分组的单个UDP数据报的总UDP有效载荷大小。该 数据报大小包括一个或多个QUIC分组报头和受保护的有效载荷， 而不是UDP或IP报头。
2. 最大数据报大小被定义为UDP有效载荷的最大大小，其可以 使用单个UDP数据报通过网络路径发送。 QUIC MUST NOT be 如果网络路径不能支持至少为1200的最大数据报大小，则使用 字节。
3. QUIC假设最小IP数据包大小至少为1280字节。 这就是IPv6 minimum size [IPv6] and is also supported by most modern IPv4 网络。 假设IPv6的最小IP报头大小为40字节，IPv6的最小IP报头大小为20字节 对于IPv4和大小为8字节的UDP报头，这会导致最大数据报 IPv6的大小为1232字节，IPv4的大小为1252字节。因此，现代IPv4 并且期望所有IPv6网络路径都能够支持QUIC。(**支持1200字节UDP有效负载的要求限制了空间 可用于32字节的IPv6扩展标头或52字节的IPv4选项 如果路径仅支持1280字节的IPv6最小MTU。 这会影响 初始数据包和路径验证**)
4. 使用Path可以发现任何大于1200字节的最大数据报大小 最大传输单元发现（PMTUD）（参见第14.2.1节）或数据报 分组化层PMTU发现（DPLPMTUD）（参见第14.3节）。
5. max_udp_payload_size传输参数（18.2节）的实施可能作为最大数据报大小的附加限制。一旦知道该值，发送方就可以避免超过该限制。然而，在获知传输参数的值之前，如果端点发送的数据报大于所允许的最小最大数据报大小1200字节，则端点有丢失数据报的风险。
6. UDP数据报不得在IP层被分段。 在IPv4中 [IPv4协议]，不分段（DF）位必须如果可能的话，被设置为 防止路径上的碎片。
7. QUIC有时要求数据报不小于特定大小;参见第8.1节作为示例。但是，数据报的大小不经过验证。也就是说，如果端点接收到特定大小的数据报，它无法知道发送方是否以相同大小发送了数据报。因此，当一个端点接收到一个不满足长度限制的数据报时，它不能关闭一个连接;端点可以丢弃这样的数据报。

### 初始数据报大小(Initial Datagram Size)

1. 客户端必须通过向初始数据包添加填充帧或通过合并初始数据包，将携带初始数据包的所有UDP数据报的有效载荷扩展到至少1200字节的最小允许最大数据报大小;参见第12.2节。初始分组甚至可以与接收器将丢弃的无效分组合并。类似地，服务器必须将所有携带ack-eliciting Initial包的UDP数据报的有效载荷扩展到至少1200字节的最小允许最大数据报大小。
2. 发送此大小的UDP数据报可确保网络路径支持 在两个方向上的合理路径最大传输单元（PMTU）。 此外，扩展初始数据包的客户端有助于降低振幅 由服务器对未经验证的客户端的响应引起的放大攻击 地址;见第8节。
3. 包含初始数据包的数据报可能超过1200字节，如果发送方 认为网络路径和对等体都支持它选择的大小。
4. 服务器必须丢弃UDP数据报中携带的初始数据包，该数据报的有效载荷小于最小允许的最大数据报大小1200字节。服务器也可以通过发送带有错误代码PROTOCOL_VIOLATION的CONNECTION_CLOSE帧立即关闭连接;参见第10.2.3节。
5. 在验证客户端地址之前，服务器必须限制它发送的字节数;参见第8节。

###  路径最大传输单元(Path Maximum Transmission Unit)

1. PMTU是整个IP数据包的最大大小，包括IP报头， UDP报头和UDP有效载荷。UDP有效载荷包括一个或多个QUIC分组 报头和受保护的有效载荷。PMTU可取决于路径特性和 因此可以随时间改变。端点在任何时间发送的最大UDP负载 给定时间被称为端点的最大数据报大小。
2. 端点应该使用DPLPMTUD（14.3节）或PMTUD（14.2.1节）来确定到目的地的路径是否支持所需的最大数据报大小而不产生碎片。在没有这些机制的情况下，QUIC端点不应该发送大于最小允许的最大数据报大小的数据报。
3. DPLPMTUD和PMTUD都发送大于当前最大值的数据报 数据报大小，称为PMTU探测。 未发送的所有QUIC数据包 在PMTU中，探测器的大小应适合最大数据报大小，以避免 数据报被分段或丢弃[RFC8085]。
4. DPLPMTUD和PMTUD都发送大于当前最大值的数据报 数据报大小，称为PMTU探测。 未发送的所有QUIC数据包 在PMTU中，探测器的大小应适合最大数据报大小，以避免 数据报被分段或丢弃[RFC8085]。
5. 每对本地和远程地址可以具有不同的PMTU。因此，实现任何类型的PMTU发现的QUIC实现应该为本地和远程IP地址的每个组合保持最大数据报大小。
6. QUIC实现在计算最大数据报大小时可能更保守，以允许未知的隧道开销或IP报头选项/扩展。

#### PMTUD对ICMP消息的处理(Handling of ICMP Messages by PMTUD)

1. PMTUD [RFC1191][RFC8201]依赖于ICMP消息的接收（即， IPv6分组太大（PTB）消息），其指示IP分组何时被丢弃 因为它大于本地路由器MTU。DPLPMTUD还可以选择使用 这些信息。 ICMP消息的这种使用方式可能容易受到攻击 由不能观察分组但可能成功地猜测 地址。这些攻击可能会将PMTU降低为 带宽低效值。
2. PMTUD [RFC1191][RFC8201]依赖于ICMP消息的接收（即， IPv6分组太大（PTB）消息），其指示IP分组何时被丢弃 因为它大于本地路由器MTU。DPLPMTUD还可以选择使用 这些信息。 ICMP消息的这种使用方式可能容易受到攻击 由不能观察分组但可能成功地猜测 地址。这些攻击可能会将PMTU降低为 带宽低效值。
3. 端点必须忽略声称PMTU已降低到以下值的ICMP消息 QUIC允许的最小最大数据报大小。
4. 使用PMTUD的QUIC端点应验证ICMP消息，以防止[RFC8201]和[RFC8085]第5.2节中指定的数据包注入。此验证“应”使用ICMP消息有效载荷中提供的引用数据包将消息与相应的传输连接关联起来（参见[DPLPMTUD]的第4.6.1节）。ICMP消息验证必须包括匹配的IP地址和UDP端口[RFC8085]，以及（如果可能）到活动QUIC会话的连接ID。端点应该忽略所有未通过验证的ICMP消息。
5. 一个终点不得根据ICMP报文增加PMTU;参见中的第6项 第三节属于[数据处理程序]。 QUIC的最大数据报大小的任何减小 对ICMP消息的响应五月在QUIC检测到损失之前为临时性 算法确定引用的数据包实际上已经丢失

### 数据报分组层PMTU发现(Datagram Packetization Layer PMTU Discovery)

1. 数据处理程序[数据处理程序]依赖于QUIC的跟踪丢失或确认 PMTU探测中携带的数据包。 使用的DPLPMTUD的PMTU探头 PADDING帧实现"使用填充数据探测"，如中所定义第4.1节属于[数据处理程序]。
2. 端点应将BASE_PLPMTU的初始值（[DPLPMTUD]第5.1节）设置为与QUIC允许的最小最大数据报大小一致。MIN_PLPMTU与BASE_PLPMTU相同。
3. 实现DPLPMTUD的QUIC端点为本地和远程IP地址的每个组合维护DPLPMTUD最大分组大小（MPS）（[DPLPMTUD]的第4.4节）。这对应于最大数据报大小。

#### DPLPMTUD和初始连接(DPLPMTUD and Initial Connectivity)

1. 从DPLPMTUD的角度来看，QUIC是公认的分组化层 （损益）。QUIC发送器因此可以进入DPLPMTUD BASE状态（第5.2节属于[数据处理程序]），此时QUIC连接握手已完成。

#### 使用DPLPMTUD验证网络路径(Validating the Network Path with DPLPMTUD)

1. QUIC是一个确认的PL;因此，QUIC发送器不实施 当处于搜索完成状态时，DPLPMTUD确认定时器;见第5.2节属于[数据处理程序]。

####  DPLPMTUD对ICMP报文的处理(Handling of ICMP Messages by DPLPMTUD)

1. 使用DPLPMTUD的端点需要验证任何接收到的ICMP PTB 消息，如中所定义第4.6节属于[数据处理程序]。 除了UDP端口验证之外，QUIC还验证ICMP消息 通过使用其它PL信息（例如，验证引号中的连接ID 任何接收到的ICMP消息的分组）。
2. 中介绍的处理ICMP消息的注意事项第14.2.1节也 如果DPLPMTUD使用这些消息，则适用。

### 发送QUIC PMTU探头(Sending QUIC PMTU Probes)

1. PMTU探测是确认引发数据包。
2. 端点可以将PMTU探测的内容限制为PING和PADDING帧， 因为大于当前最大数据报大小的分组更多 可能被网络丢弃。 中携带的QUIC数据包丢失 PMTU探测因此不是拥塞的可靠指示不应 触发拥塞控制反应;参见中的第7项第三节属于[数据处理程序]。 但是，PMTU探测会消耗拥塞窗口，这可能会延迟后续操作 由应用程序传输。

#### 包含源连接ID的PMTU探测器(PMTU Probes Containing Source Connection ID)

1. 依赖于目的地连接ID字段来路由传入QUIC数据包的端点可能需要将连接ID包括在PMTU探测中，以将任何结果ICMP消息（第14.2.1节）路由回正确的端点。然而，只有长报头分组（17.2节）包含源连接ID字段，并且一旦握手完成，长报头分组就不会被对等体解密或确认。
2. 构造PMTU探测器的一种方法是将具有长报头的数据包（如握手或0-RTT数据包（第17.2节））与单个UDP数据报中的短报头数据包合并（参见第12.2节）。如果产生的PMTU探测到达端点，则具有长报头的数据包将被忽略，但短报头数据包将被确认。如果PMTU探测器导致发送ICMP消息，则探测器的第一部分将在该消息中引用。如果Source Connection ID字段在探测器的引号部分，则可用于路由或验证ICMP消息。(**使用具有长报头的数据包的目的只是为了确保 ICMP消息中引用的数据包包含源连接 ID字段。 此数据包不必是有效数据包，可以发送 即使当前没有对该类型的分组的使用。**)

## 版本(Versions)

1. QUIC版本使用32位无符号数字标识。
2. 版本0x00000000被保留以表示版本协商。 这个 规范的版本由编号0x00000001标识。
3. 其他版本的QUIC可能具有与此版本不同的属性。 该 QUIC的属性，这些属性保证在所有版本的 协议在[快速不变]中描述。
4. QUIC的0x00000001版本使用TLS作为加密握手协议，如 描述于[快速TLS]。
5. QUIC的0x00000001版本使用TLS作为加密握手协议，如 描述于[快速TLS]。
6. 遵循模式 0x?a?a?a?a  的版本 a被保留用于强制执行版本协商--即，所有字节的低四位是1010（二进制）的任何版本号。客户端或服务器可以公布对这些保留版本的支持。
7. 保留的版本号永远不会代表真实的的协议;客户端可以使用 这些版本号中的一个，并期望服务器将启动 版本协商;服务器可以通告对这些版本之一的支持 并且可以预期客户端忽略该值。

## 可变长度整数编码(Variable-Length Integer Encoding)

1. QUIC数据包和帧通常使用可变长度编码进行非负编码 整数值。 这种编码方式可确保较小的整数值需要较少的 要编码的字节。
2. QUIC可变长度整数编码保留两个最高有效位 对整数编码长度的以2为底的对数进行编码 以字节为单位。 整数值在其余位上编码，以网络字节为单位 秩序。
3. 这意味着整数在1、2、4或8字节上编码，并且可以编码6-， 分别为14位、30位或62位值。 表4总结了 编码属性。
2MSB 	Length 	Usable Bits 	Range
00 		1 		6 				0-63
01 		2 		14 				0-16383
10 		4 		30 				0-1073741823
11 		8 		62 				0-4611686018427387903

4. 这意味着整数在1、2、4或8字节上编码，并且可以编码6-， 分别为14位、30位或62位值。 表4总结了 编码属性。
5. 除了帧类型字段之外，不需要在所需的最小字节数上对值进行编码;参见第12.4节。
6. 版本（第15节），报头中发送的数据包编号 （第17.1节），以及长报头数据包中连接ID的长度 （第17.2节）使用整数描述，但不使用这种编码。

## 数据包格式(Packet Formats)

1. 所有数值都按网络字节顺序（即big endian）编码，并且 所有字段大小都是以比特为单位。 十六进制表示法用于描述 字段的值。

### 包号编解码(Packet Number Encoding and Decoding)

1. 数据包编号是0到262-1范围内的整数（第12.3节）。当出现在长或短分组报头中时，它们被编码为1到4个字节。通过仅包括分组号的最低有效位来减少表示分组号所需的位数。
2. 已编码的数据包编号按照中所述进行保护 第5.4节属于[快速TLS]。
3. 已编码的数据包编号按照中所述进行保护 第5.4节属于[快速TLS]。
4. 在接收到对分组号空间的确认之前，完整分组 数必须包括在内;如下文所述，其将不被截断
5. 结果，分组号编码的大小至少多一位 大于连续未确认分组数的以2为底的对数 号码，包括新数据包。 伪码及包号示例 编码见附录A.2。
6. 在接收机处，在恢复之前去除对分组号的保护 完整的分组号。然后，基于以下等式重构完整的分组编号： 存在的有效位数、这些位的值以及最大 在成功验证的数据包中接收到的数据包编号。恢复 要成功删除数据包，需要完整的数据包编号 保护。
7. 一旦去除了报头保护，则通过查找 最接近下一个预期分组的分组编号值。 下一个 预期分组是最高接收分组号加1。 伪码和 分组号解码的示例可以在 Appendix A.3.

### 长报头数据包(Long Header Packets)

Long Header Packet {
  Header Form (1) = 1 
  Fixed Bit (1) = 1 
  Long Packet Type (2) 
  Type-Specific Bits (4) 
  Version (32) 
  Destination Connection ID Length (8) 
  Destination Connection ID (0..160) 
  Source Connection ID Length (8) 
  Source Connection ID (0..160) 
  Type-Specific Payload (..) 
}

1. 长标头用于在建立之前发送的数据包 1-RTT密钥。一旦1-RTT密钥可用， 发送方切换到使用短报头发送分组 （第17.3节）. 长格式允许特殊的数据包--比如 版本协商数据包--以统一的固定长度表示 分组格式。使用长报头的数据包包含以下字段：
2. 
Header Form:   字节0（第一个字节）的最高有效位（0x80）设置为1，用于 长报头。
Fixed Bit: 字节0的下一位（0x 40）被设置为1，除非分组是版本协商分组。此位包含零值的数据包在此版本中不是有效数据包，必须丢弃。该位的值为1允许QUIC与其它协议共存;参见[RFC 7983]。
Long Packet Type: 字节0的下两位（掩码为0x30）包含数据包类型。 中列出了数据包类型表五。
Type-Specific Bits: 字节0的低四位（掩码为0x0f的位）的语义为 由分组类型确定。
Version: QUIC版本是第一个字节之后的32位字段。 此字段 指示正在使用的QUIC版本，并确定如何 解释协议字段。
Destination Connection ID Length: 版本后面的字节包含目标的长度（以字节为单位 连接ID字段。此长度编码为8位 无符号整数。 在QUIC版本1中，该值不得超过20字节。 接收值大于20的版本1长标头的终结点 必须丢弃数据包。 为了正确地形成版本协商分组， 服务器应该能够从其他QUIC版本中读取更长的连接ID。
Destination Connection ID:目标连接ID字段位于目标连接ID之后 长度字段，指示此字段的长度。 第7.2节更详细地描述了该字段的使用。
Source Connection ID Length:目标连接ID后面的字节包含其后的源连接ID字段的长度（以字节为单位）。此长度编码为8位无符号整数。在QUIC版本1中，该值不得超过20字节。接收到值大于20的版本1长报头的端点必须丢弃该数据包。为了正确地形成版本协商包，服务器应该能够从其他QUIC版本读取更长的连接ID。
Source Connection ID: 源连接ID字段跟在源连接ID长度字段之后， 其指示该字段的长度。第7.2节 详细介绍了此字段的用法。
Type-Specific Payload: 分组的其余部分（如果有的话）是类型特定的。


在此版本的QUIC中，具有长报头的包类型如下 定义：
Type 	Name 		Section
0x00 	Initial 	Section 17.2.2
0x01 	0-RTT 		Section 17.2.3
0x02 	Handshake 	Section 17.2.4
0x03 	Retry 		Section 17.2.5 

3. 报头格式位、目标和源连接ID长度、目标 和源连接ID字段以及长报头分组的版本字段被 与版本无关。第一个字节中的其他字段是版本特定的。 见[快速不变量]有关不同版本的数据包如何 QUIC被解释。
4. 字段和有效载荷的解释特定于版本，并且 数据包类型。 中描述了此版本的类型特定语义 以下各节，此版本QUIC中的几个长报头数据包 包含这些附加字段：

1. Reserved Bits: 字节0的两位（掩码为0x0c的位）在多种数据包类型中保留。这些位使用报头保护来保护;参见[QUIC-TLS]的第5.4节。保护前包含的值必须设置为0。端点必须将在删除数据包和报头保护后收到的这些位具有非零值的数据包视为PROTOCOL_VIOLATION类型的连接错误。仅在移除报头保护之后丢弃这样的分组可能使端点暴露于攻击;参见[QUIC-TLS]的第9.5节。
2. Packet Number Length: 在包含数据包编号字段的数据包类型中，字节0的最低有效两位（掩码为0x03的两位）包含数据包编号字段的长度，编码为无符号两位整数，比数据包编号字段的字节长度小1。即，分组号字段的长度是该字段的值加1。这些位使用报头保护来保护;参见[QUIC-TLS]的第5.4节。
3. Length: 这是数据包剩余部分（即数据包编号和有效负载字段）的长度（以字节为单位），编码为可变长度整数（第16节）。
4. Packet Number: 此字段的长度为1到4个字节。使用报头保护来保护分组号;参见[QUIC-TLS]的第5.4节。分组号字段的长度被编码在字节0的分组号长度比特中;参见上文。
5. Packet Payload: 这是数据包的有效负载--包含一系列帧--使用数据包保护进行保护。


#### 版本协商包(Version Negotiation Packet)

1. 版本协商数据包本质上不是特定于版本的。收到后 客户端时，它将根据 值为0的版本字段。
2. 版本协商数据包是对包含 服务器不支持的版本。 它只由服务器发送。
3. 版本协商包的布局是
Version Negotiation Packet {
  Header Form (1) = 1 
  Unused (7) 
  Version (32) = 0 
  Destination Connection ID Length (8) 
  Destination Connection ID (0..2040) 
  Source Connection ID Length (8) 
  Source Connection ID (0..2040) 
  Supported Version (32) ... 
}
4. "未使用"字段中的值由服务器设置为任意值。客户端必须忽略此字段的值。当QUIC可能与其他协议复用时（参见[RFC7983]），服务器应该将该字段的最高有效位（0x40）设置为1，以便版本协商数据包看起来具有固定位字段。注意，QUIC的其他版本可能不会给出类似的建议。
5. 版本协商数据包的版本字段必须设置为0x00000000。
6. 所述服务器必须包括的源连接ID字段中的值 在目的连接ID字段中输入它接收到的数据包。 源的值 连接ID必须从接收的目标连接ID复制 分组，其最初由客户端随机选择。 两者呼应 连接ID为客户端提供了服务器收到数据包的某种保证 并且版本协商分组不是由 未观察到初始数据包。
7. QUIC的未来版本可能对连接ID的长度有不同的要求。特别是，连接ID可能具有较小的最小长度或较大的最大长度。因此，用于连接ID的版本特定规则一定不能影响关于是否发送版本协商分组的决定。
8. 版本协商数据包的其余部分是32位版本的列表 服务器支持的。
9. 版本协商数据包未得到确认。 它仅作为响应发送 指示不支持的版本的分组;参见第5.2.2节。
10. 版本协商数据包不包括数据包编号和长度 存在于使用长报头形式的其它分组中的字段。 因此， 版本协商分组消耗整个UDP数据报。
11. 有关版本协商过程的描述，请参见第6节。

#### 初始数据包(Initial Packet)

1. 初始数据包使用类型值为0x 00的长报头。 它携带 客户端和服务器发送的用于进行密钥交换的第一CRYPTO帧; 它在任一方向上携带ACK帧。
Initial Packet {
  Header Form (1) = 1 
  Fixed Bit (1) = 1 
  Long Packet Type (2) = 0 
  Reserved Bits (2) 
  Packet Number Length (2) 
  Version (32) 
  Destination Connection ID Length (8) 
  Destination Connection ID (0..160) 
  Source Connection ID Length (8) 
  Source Connection ID (0..160) 
  Token Length (i) 
  Token (..) 
  Length (i) 
  Packet Number (8..32) 
  Packet Payload (8..) 
}
2. 初始数据包包含长报头以及长度和数据包 Number fields; see Section 17.2. 第一个字节包含保留和 Packet Number Length bits; see also Section 17.2. 源头之间 连接ID和长度字段，还有两个特定于的附加字段 初始数据包。
3. Token Length: 一个可变长度整数，指定Token字段的长度（以字节为单位）。 如果不存在标记，则此值为0。 服务器发送的初始数据包 必须将令牌长度字段设置为0;接收初始值的客户端 令牌长度字段为非零的数据包必须丢弃该数据包或 生成PROTOCOL_VIOLATION类型的连接错误。
Token: 以前在重试数据包中提供的令牌值，或 新令牌帧;参见第8.1节。
4. 为了防止版本不敏感的中间盒篡改，初始数据包 使用连接和版本特定的密钥（初始密钥）进行保护，如 described in [QUIC-TLS]. 此保护不提供机密性或 完整性，以防止攻击者可以观察数据包，但它确实可以防止 无法通过欺骗初始数据包观察数据包的攻击者
5. 客户端和服务器对包含以下内容的任何数据包使用初始数据包类型 初始加密握手消息。这包括新的 需要创建包含初始加密消息的数据包，例如 在接收到重试分组之后发送的分组;参见第17.2.5节。
6. 服务器发送其第一初始分组以响应客户端初始。 A类 服务器可以发送多个初始数据包。 加密密钥交换可以 需要该数据的多次往返或重传。
7. 初始分组的有效载荷包括CRYPTO帧（或多个CRYPTO帧），该CRYPTO帧包含 密码握手消息、ACK帧或两者。 PING、填充和 也允许使用0x1c类型的CONNECTION_CLOSE帧。 一种端点，其 接收到包含其它帧的初始数据包时，可以丢弃 数据包是虚假的，或者将其视为连接错误。
8. 由客户端发送的第一分组总是包括CRYPTO帧，该CRYPTO帧包含第一密码握手消息的开始或全部。发送的第一CRYPTO帧总是在偏移0处开始;参见第7节。
9. 请注意，如果服务器发送TLS HelloRetryRequest（请参见第4.7节属于[快速TLS]），则客户端将发送另一系列初始分组。这些 初始数据包将继续加密握手，并将包含 CRYPTO帧开始于与发送的CRYPTO帧的大小匹配的偏移 在第一批初始数据包中。

#### 放弃初始数据包(Abandoning Initial Packets)

1. 客户端在发送其 第一握手分组。 服务器停止发送和处理初始数据包 当它接收到它的第一握手分组时。 尽管数据包可能还在 飞行或等待确认，则不需要进一步 交换超过这个点。 初始数据包保护密钥将被丢弃（请参见 第4.9.1节属于[快速TLS]）以及任何丢失恢复和拥塞 控制状态见第6.4节属于[快速恢复]。
2. CRYPTO帧中的任何数据都将被丢弃--并且不再重新传输--当 初始关键帧将被丢弃。

#### 往返时间(0-RTT)

1. 0-RTT分组使用类型值为0x01的长报头，其后是长度和分组编号字段;参见第17.2节。第一个字节包含保留和分组号长度位;参见第17.2节。0-RTT数据包用于在握手完成之前将"早期"数据从客户端传送到服务器，作为第一次飞行的一部分。作为TLS握手的一部分，服务器可以接受或拒绝此早期数据。
2. 有关0-RTT数据及其局限性的讨论，请参见[TLS 13]第2.3节。
0-RTT Packet {
  Header Form (1) = 1 
  Fixed Bit (1) = 1 
  Long Packet Type (2) = 1 
  Reserved Bits (2) 
  Packet Number Length (2) 
  Version (32) 
  Destination Connection ID Length (8) 
  Destination Connection ID (0..160) 
  Source Connection ID Length (8) 
  Source Connection ID (0..160) 
  Length (i) 
  Packet Number (8..32) 
  Packet Payload (8..) 
}
受0-RTT保护的数据包的数据包编号使用与受1-RTT保护的数据包相同的空间 数据包。
3. 客户端收到重试数据包后，0-RTT数据包可能已 丢失或被服务器丢弃。 一个客户应该尝试重新发送数据 0-RTT数据包之后，它发送一个新的初始数据包。 新数据包编号必须是 用于发送的任何新分组;如中所述章节17.2.5.3， 重用分组号可能损害分组保护。
4. 客户端仅在握手后接收其0-RTT数据包的确认 已完成，如中所定义第4.1.1节属于[快速TLS]。
5. 客户端一旦开始处理来自服务器的1-RTT数据包，就不能发送0-RTT数据包。这意味着0-RTT分组不能包含对来自1-RTT分组的帧的任何响应。例如，客户端不能在0-RTT数据包中发送ACK帧，因为它只能确认1-RTT数据包。必须在1-RTT分组中携带对1-RTT分组的确认。
6. 服务器应该处理违反记住的限制（7.4.1节） 作为适当类型的连接错误（例如，FLOW_CONTROL_ERROR 用于超过流数据限制）。

#### 握手数据包(Handshake Packet)

1. 握手分组使用类型值为0x02的长报头，其后是长度和分组编号字段;参见第17.2节。第一个字节包含保留和分组号长度位;参见第17.2节。它用于携带来自服务器和客户端的加密握手消息和确认。
Handshake Packet {
  Header Form (1) = 1 
  Fixed Bit (1) = 1 
  Long Packet Type (2) = 2 
  Reserved Bits (2) 
  Packet Number Length (2) 
  Version (32) 
  Destination Connection ID Length (8) 
  Destination Connection ID (0..160) 
  Source Connection ID Length (8) 
  Source Connection ID (0..160) 
  Length (i) 
  Packet Number (8..32) 
  Packet Payload (8..) 
}
2. 一旦客户端从服务器接收到握手包，它就使用握手 用于发送后续加密握手消息和确认的数据包 到服务器。
3. 握手数据包中的"目标连接ID"字段包含连接 由分组的接收者选择的ID;源连接ID 包括分组的发送方希望使用的连接ID;见 Section 7.2. 
4. 握手数据包有自己的数据包编号空间，因此第一个 服务器发送的握手数据包包含数据包编号0。
5. 该分组的有效载荷包含CRYPTO帧并且可以包含PING， 填充或ACK帧。握手数据包可能包含CONNECTION_CLOSE帧 类型为0x1c。端点必须将收到的握手数据包与其他 帧作为PROTOCOL_VIOLATION类型的连接错误。
6. 类似于初始数据包（参见www.example.com部分17.2.2.1），CRYPTO帧中的数据 握手数据包被丢弃--并且不再重新传输--当握手时 保护密钥被丢弃。

#### 重试数据包(Retry Packet)

1. 








